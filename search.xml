<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2019/03/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>
<hr>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Vue过渡 &amp; 动画</title>
    <url>/2021/05/20/vue/3.%E8%BF%87%E6%B8%A1%20&amp;%20%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<h1 id="Vue过渡-amp-动画"><a href="#Vue过渡-amp-动画" class="headerlink" title="Vue过渡 &amp; 动画"></a>Vue过渡 &amp; 动画</h1><span id="more"></span>
<hr>
<h1 id="进入-离开-amp-列表过渡"><a href="#进入-离开-amp-列表过渡" class="headerlink" title="进入/离开 &amp; 列表过渡"></a>进入/离开 &amp; 列表过渡</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><hr>
<p>Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。包括以下工具：</p>
<ul>
<li>在 CSS 过渡和动画中自动应用 class</li>
<li>可以配合使用第三方 CSS 动画库，如 Animate.css</li>
<li>在过渡钩子函数中使用 JavaScript 直接操作 DOM</li>
<li>可以配合使用第三方 JavaScript 动画库，如 Velocity.js</li>
</ul>
<h2 id="单元素-组件的过渡"><a href="#单元素-组件的过渡" class="headerlink" title="单元素/组件的过渡"></a>单元素/组件的过渡</h2><hr>
<h3 id="过渡的类名"><a href="#过渡的类名" class="headerlink" title="过渡的类名"></a>过渡的类名</h3><p>在进入/离开的过渡中，会有 6 个 class 切换。</p>
<ol>
<li><code>v-enter</code>：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。</li>
<li><code>v-enter-active</code>：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</li>
<li><code>v-enter-to</code>：<strong>2.1.8 版及以上</strong>定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 <code>v-enter</code> 被移除)，在过渡/动画完成之后移除。</li>
<li><code>v-leave</code>：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。</li>
<li><code>v-leave-active</code>：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</li>
<li><code>v-leave-to</code>：<strong>2.1.8 版及以上</strong>定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 <code>v-leave</code> 被删除)，在过渡/动画完成之后移除。</li>
</ol>
<p><img data-src="https://cn.vuejs.org/images/transition.png" alt="Transition Diagram"></p>
<p>对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 <code>&lt;transition&gt;</code>，则 <code>v-</code> 是这些类名的默认前缀。如果你使用了 <code>&lt;transition name=&quot;my-transition&quot;&gt;</code>，那么 <code>v-enter</code> 会替换为 <code>my-transition-enter</code>。</p>
<p><code>v-enter-active</code> 和 <code>v-leave-active</code> 可以控制进入/离开过渡的不同的缓和曲线，在下面章节会有个示例说明。</p>
<h3 id="CSS-过渡"><a href="#CSS-过渡" class="headerlink" title="CSS 过渡"></a>CSS 过渡</h3><p>常用的过渡都是使用 CSS 过渡。</p>
<p>下面是一个简单例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example-1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;show = !show&quot;</span>&gt;</span></span><br><span class="line">    Toggle render</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">&quot;slide-fade&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;show&quot;</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&#x27;#example-1&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">show</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="comment">/* 可以设置不同的进入和离开动画 */</span></span></span><br><span class="line"><span class="css"><span class="comment">/* 设置持续时间和动画函数 */</span></span></span><br><span class="line"><span class="css"><span class="selector-class">.slide-fade-enter-active</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">transition</span>: all .<span class="number">3s</span> ease;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.slide-fade-leave-active</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">transition</span>: all .<span class="number">8s</span> <span class="built_in">cubic-bezier</span>(<span class="number">1.0</span>, <span class="number">0.5</span>, <span class="number">0.8</span>, <span class="number">1.0</span>);</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.slide-fade-enter</span>, <span class="selector-class">.slide-fade-leave-to</span></span></span><br><span class="line"><span class="css"><span class="comment">/* .slide-fade-leave-active for below version 2.1.8 */</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">10px</span>);</span></span><br><span class="line"><span class="css">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="CSS-动画"><a href="#CSS-动画" class="headerlink" title="CSS 动画"></a>CSS 动画</h3><p>CSS 动画用法同 CSS 过渡，区别是在动画中 <code>v-enter</code> 类名在节点插入 DOM 后不会立即删除，而是在 <code>animationend</code> 事件触发时删除。</p>
<p>示例：(省略了兼容性前缀)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example-2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;show = !show&quot;</span>&gt;</span>Toggle show<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">&quot;bounce&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;show&quot;</span>&gt;</span>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris facilisis enim libero, at lacinia diam fermentum id. Pellentesque habitant morbi tristique senectus et netus.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&#x27;#example-2&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">show</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.bounce-enter-active</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">animation</span>: bounce-in .<span class="number">5s</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.bounce-leave-active</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">animation</span>: bounce-in .<span class="number">5s</span> reverse;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="keyword">@keyframes</span> bounce-in &#123;</span></span><br><span class="line"><span class="css">  <span class="number">0%</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0</span>);</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="number">50%</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.5</span>);</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="number">100%</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义过渡的类名"><a href="#自定义过渡的类名" class="headerlink" title="自定义过渡的类名"></a>自定义过渡的类名</h3><p>我们可以通过以下 attribute 来自定义过渡类名：</p>
<ul>
<li><code>enter-class</code></li>
<li><code>enter-active-class</code></li>
<li><code>enter-to-class</code></li>
<li><code>leave-class</code></li>
<li><code>leave-active-class</code></li>
<li><code>leave-to-class</code></li>
</ul>
<p>他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 <a href="https://daneden.github.io/animate.css/">Animate.css</a> 结合使用十分有用。</p>
<p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/animate.css@3.5.1&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example-3&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;show = !show&quot;</span>&gt;</span></span><br><span class="line">    Toggle render</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">&quot;custom-classes-transition&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">enter-active-class</span>=<span class="string">&quot;animated tada&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">leave-active-class</span>=<span class="string">&quot;animated bounceOutRight&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;show&quot;</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&#x27;#example-3&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">show</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="同时使用过渡和动画"><a href="#同时使用过渡和动画" class="headerlink" title="同时使用过渡和动画"></a>同时使用过渡和动画</h3><p>Vue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 <code>transitionend</code> 或 <code>animationend</code>，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。</p>
<p>但是，在一些场景中，你需要给同一个元素同时设置两种过渡动效，比如 <code>animation</code> 很快的被触发并完成了，而 <code>transition</code> 效果还没结束。在这种情况中，你就需要使用 <code>type</code> attribute 并设置 <code>animation</code> 或 <code>transition</code> 来明确声明你需要 Vue 监听的类型。</p>
<h3 id="显性的过渡持续时间"><a href="#显性的过渡持续时间" class="headerlink" title="显性的过渡持续时间"></a>显性的过渡持续时间</h3><p>在很多情况下，Vue 可以自动得出过渡效果的完成时机。默认情况下，Vue 会等待其在过渡效果的根元素的第一个 <code>transitionend</code> 或 <code>animationend</code> 事件。然而也可以不这样设定——比如，我们可以拥有一个精心编排的一系列过渡效果，其中一些嵌套的内部元素相比于过渡效果的根元素有延迟的或更长的过渡效果。</p>
<p>在这种情况下你可以用 <code>&lt;transition&gt;</code> 组件上的 <code>duration</code> prop 定制一个显性的过渡持续时间 (以毫秒计)：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">:duration</span>=<span class="string">&quot;1000&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你也可以定制进入和移出的持续时间：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">:duration</span>=<span class="string">&quot;&#123; enter: 500, leave: 800 &#125;&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="JavaScript-钩子"><a href="#JavaScript-钩子" class="headerlink" title="JavaScript 钩子"></a>JavaScript 钩子</h3><p>可以在 attribute 中声明 JavaScript 钩子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;transition</span><br><span class="line">  v-on:before-enter=&quot;beforeEnter&quot;</span><br><span class="line">  v-on:enter=&quot;enter&quot;</span><br><span class="line">  v-on:after-enter=&quot;afterEnter&quot;</span><br><span class="line">  v-on:enter-cancelled=&quot;enterCancelled&quot;</span><br><span class="line"></span><br><span class="line">  v-on:before-leave=&quot;beforeLeave&quot;</span><br><span class="line">  v-on:leave=&quot;leave&quot;</span><br><span class="line">  v-on:after-leave=&quot;afterLeave&quot;</span><br><span class="line">  v-on:leave-cancelled=&quot;leaveCancelled&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;!-- ... --&gt;</span><br><span class="line">&lt;/transition&gt;</span><br><span class="line">// ...</span><br><span class="line">methods: &#123;</span><br><span class="line">  // --------</span><br><span class="line">  // 进入中</span><br><span class="line">  // --------</span><br><span class="line"></span><br><span class="line">  beforeEnter: function (el) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;,</span><br><span class="line">  // 当与 CSS 结合使用时</span><br><span class="line">  // 回调函数 done 是可选的</span><br><span class="line">  enter: function (el, done) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    done()</span><br><span class="line">  &#125;,</span><br><span class="line">  afterEnter: function (el) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;,</span><br><span class="line">  enterCancelled: function (el) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // --------</span><br><span class="line">  // 离开时</span><br><span class="line">  // --------</span><br><span class="line"></span><br><span class="line">  beforeLeave: function (el) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;,</span><br><span class="line">  // 当与 CSS 结合使用时</span><br><span class="line">  // 回调函数 done 是可选的</span><br><span class="line">  leave: function (el, done) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    done()</span><br><span class="line">  &#125;,</span><br><span class="line">  afterLeave: function (el) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;,</span><br><span class="line">  // leaveCancelled 只用于 v-show 中</span><br><span class="line">  leaveCancelled: function (el) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些钩子函数可以结合 CSS <code>transitions/animations</code> 使用，也可以单独使用。</p>
<p>当只用 JavaScript 过渡的时候，<strong>在 <code>enter</code> 和 <code>leave</code> 中必须使用 <code>done</code> 进行回调</strong>。否则，它们将被同步调用，过渡会立即完成。</p>
<p>推荐对于仅使用 JavaScript 过渡的元素添加 <code>v-bind:css=&quot;false&quot;</code>，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。</p>
<p>一个使用 Velocity.js 的简单例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">Velocity 和 jQuery.animate 的工作方式类似，也是用来实现 JavaScript 动画的一个很棒的选择</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example-4&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;show = !show&quot;</span>&gt;</span></span><br><span class="line">    Toggle</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-on:before-enter</span>=<span class="string">&quot;beforeEnter&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-on:enter</span>=<span class="string">&quot;enter&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-on:leave</span>=<span class="string">&quot;leave&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:css</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;show&quot;</span>&gt;</span></span><br><span class="line">      Demo</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&#x27;#example-4&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">show</span>: <span class="literal">false</span></span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">beforeEnter</span>: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      el.style.opacity = <span class="number">0</span></span></span><br><span class="line"><span class="javascript">      el.style.transformOrigin = <span class="string">&#x27;left&#x27;</span></span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">enter</span>: <span class="function"><span class="keyword">function</span> (<span class="params">el, done</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      Velocity(el, &#123; <span class="attr">opacity</span>: <span class="number">1</span>, <span class="attr">fontSize</span>: <span class="string">&#x27;1.4em&#x27;</span> &#125;, &#123; <span class="attr">duration</span>: <span class="number">300</span> &#125;)</span></span><br><span class="line"><span class="javascript">      Velocity(el, &#123; <span class="attr">fontSize</span>: <span class="string">&#x27;1em&#x27;</span> &#125;, &#123; <span class="attr">complete</span>: done &#125;)</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">leave</span>: <span class="function"><span class="keyword">function</span> (<span class="params">el, done</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      Velocity(el, &#123; <span class="attr">translateX</span>: <span class="string">&#x27;15px&#x27;</span>, <span class="attr">rotateZ</span>: <span class="string">&#x27;50deg&#x27;</span> &#125;, &#123; <span class="attr">duration</span>: <span class="number">600</span> &#125;)</span></span><br><span class="line"><span class="javascript">      Velocity(el, &#123; <span class="attr">rotateZ</span>: <span class="string">&#x27;100deg&#x27;</span> &#125;, &#123; <span class="attr">loop</span>: <span class="number">2</span> &#125;)</span></span><br><span class="line"><span class="javascript">      Velocity(el, &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">rotateZ</span>: <span class="string">&#x27;45deg&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">translateY</span>: <span class="string">&#x27;30px&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">translateX</span>: <span class="string">&#x27;30px&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">opacity</span>: <span class="number">0</span></span></span><br><span class="line"><span class="javascript">      &#125;, &#123; <span class="attr">complete</span>: done &#125;)</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue基础-易遗漏点</title>
    <url>/2021/05/17/vue/1.%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Vue基础-易遗漏点"><a href="#Vue基础-易遗漏点" class="headerlink" title="Vue基础-易遗漏点"></a>Vue基础-易遗漏点</h1><span id="more"></span>
<hr>
<h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><hr>
<p>在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p>
<p>为了解决这个问题，Vue.js 为 <code>v-on</code> 提供了<strong>事件修饰符</strong>。之前提过，修饰符是由点开头的指令后缀来表示的。</p>
<ul>
<li><code>.stop</code></li>
<li><code>.prevent</code></li>
<li><code>.capture</code></li>
<li><code>.self</code></li>
<li><code>.once</code></li>
<li><code>.passive</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click.stop</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> @<span class="attr">submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click.stop.prevent</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> @<span class="attr">submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.capture</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.self</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 <code>@click.prevent.self</code> 会阻止<strong>所有的点击</strong>，而 <code>@click.self.prevent</code> 只会阻止对元素自身的点击。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click.once</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>不像其它只能对原生的 DOM 事件起作用的修饰符，<code>.once</code> 修饰符还能被用到自定义的事件上。如果你还没有阅读关于组件的文档，现在大可不必担心。</p>
<p>Vue 还对应 <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener##Parameters"><code>addEventListener</code> 中的 <code>passive</code> 选项</a>提供了 <code>.passive</code> 修饰符。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">scroll.passive</span>=<span class="string">&quot;onScroll&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个 <code>.passive</code> 修饰符尤其能够提升移动端的性能。</p>
<p>不要把 <code>.passive</code> 和 <code>.prevent</code> 一起使用，因为 <code>.prevent</code> 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，<code>.passive</code> 会告诉浏览器你<em>不</em>想阻止事件的默认行为。</p>
<h2 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h2><hr>
<p>在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 <code>v-on</code> 在监听键盘事件时添加按键修饰符：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.enter</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你可以直接将 <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values"><code>KeyboardEvent.key</code></a> 暴露的任意有效按键名转换为 kebab-case 来作为修饰符。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.page-down</span>=<span class="string">&quot;onPageDown&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，处理函数只会在 <code>$event.key</code> 等于 <code>PageDown</code> 时被调用。</p>
<h3 id="按键码"><a href="#按键码" class="headerlink" title="按键码"></a>按键码</h3><h2 id="系统修饰键"><a href="#系统修饰键" class="headerlink" title="系统修饰键"></a>系统修饰键</h2><hr>
<p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</p>
<ul>
<li><code>.ctrl</code></li>
<li><code>.alt</code></li>
<li><code>.shift</code></li>
<li><code>.meta</code></li>
</ul>
<p>注意：在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)。在其他特定键盘上，尤其在 MIT 和 Lisp 机器的键盘、以及其后继产品，比如 Knight 键盘、space-cadet 键盘，meta 被标记为“META”。在 Symbolics 键盘上，meta 被标记为“META”或者“Meta”。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Alt + C --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.alt.67</span>=<span class="string">&quot;clear&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Ctrl + Click --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.ctrl</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>请注意修饰键与常规按键不同，在和 <code>keyup</code> 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 <code>ctrl</code> 的情况下释放其它按键，才能触发 <code>keyup.ctrl</code>。而单单释放 <code>ctrl</code> 也不会触发事件。如果你想要这样的行为，请为 <code>ctrl</code> 换用 <code>keyCode</code>：<code>keyup.17</code>。</p>
<h3 id="exact-修饰符"><a href="#exact-修饰符" class="headerlink" title=".exact 修饰符"></a><code>.exact</code> 修饰符</h3><p><code>.exact</code> 修饰符允许你控制由精确的系统修饰符组合触发的事件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.ctrl</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.ctrl.exact</span>=<span class="string">&quot;onCtrlClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.exact</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="headerlink" title="鼠标按钮修饰符"></a>鼠标按钮修饰符</h3><ul>
<li><code>.left</code></li>
<li><code>.right</code></li>
<li><code>.middle</code></li>
</ul>
<p>这些修饰符会限制处理函数仅响应特定的鼠标按钮。</p>
<h1 id="表单绑定输入"><a href="#表单绑定输入" class="headerlink" title="表单绑定输入"></a>表单绑定输入</h1><h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><hr>
<p>你可以用 <code>v-model</code> 指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 <code>v-model</code> 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。</p>
<p><code>v-model</code> 会忽略所有表单元素的 <code>value</code>、<code>checked</code>、<code>selected</code> attribute 的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 <code>data</code> 选项中声明初始值。</p>
<p><code>v-model</code> 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p>
<ul>
<li>text 和 textarea 元素使用 <code>value</code> property 和 <code>input</code> 事件；</li>
<li>checkbox 和 radio 使用 <code>checked</code> property 和 <code>change</code> 事件；</li>
<li>select 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件。</li>
</ul>
<p>对于需要使用<a href="https://zh.wikipedia.org/wiki/%E8%BE%93%E5%85%A5%E6%B3%95">输入法</a> (如中文、日文、韩文等) 的语言，你会发现 <code>v-model</code> 不会在输入法组合文字过程中得到更新。如果你也想处理这个过程，请使用 <code>input</code> 事件。</p>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><hr>
<h3 id="lazy"><a href="#lazy" class="headerlink" title=".lazy"></a><code>.lazy</code></h3><p>在默认情况下，<code>v-model</code> 在每次 <code>input</code> 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 <code>lazy</code> 修饰符，从而转为在 <code>change</code> 事件_之后_进行同步：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在“change”时而非“input”时更新 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.lazy</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="number"><a href="#number" class="headerlink" title=".number"></a><code>.number</code></h3><p>如果想自动将用户的输入值转为数值类型，可以给 <code>v-model</code> 添加 <code>number</code> 修饰符：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.number</span>=<span class="string">&quot;age&quot;</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这通常很有用，因为即使在 <code>type=&quot;number&quot;</code> 时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 <code>parseFloat()</code> 解析，则会返回原始的值。</p>
<h3 id="trim"><a href="#trim" class="headerlink" title=".trim"></a><code>.trim</code></h3><p>如果要自动过滤用户输入的首尾空白字符，可以给 <code>v-model</code> 添加 <code>trim</code> 修饰符：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.trim</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h1><h2 id="监听子组件事件"><a href="#监听子组件事件" class="headerlink" title="监听子组件事件"></a>监听子组件事件</h2><hr>
<h3 id="在组件上使用-v-model"><a href="#在组件上使用-v-model" class="headerlink" title="在组件上使用 v-model"></a>在组件上使用 <code>v-model</code></h3><p>自定义事件也可以用于创建支持 <code>v-model</code> 的自定义输入组件。记住：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;searchText&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:value</span>=<span class="string">&quot;searchText&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">input</span>=<span class="string">&quot;searchText = $event.target.value&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure>

<p>当用在组件上时，<code>v-model</code> 则会这样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">custom-input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:value</span>=<span class="string">&quot;searchText&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">input</span>=<span class="string">&quot;searchText = $event&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为了让它正常工作，这个组件内的 <code>&lt;input&gt;</code> 必须：</p>
<ul>
<li>将其 <code>value</code> attribute 绑定到一个名叫 <code>value</code> 的 prop 上</li>
<li>在其 <code>input</code> 事件被触发时，将新的值通过自定义的 <code>input</code> 事件抛出</li>
</ul>
<p>写成代码之后是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">	:value=&quot;value&quot;</span><br><span class="line">	@input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span><br><span class="line">&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">	name: &#x27;custom-input&#x27;,</span><br><span class="line">	props: [&#x27;value&#x27;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在 <code>v-model</code> 就应该可以在这个组件上完美地工作起来了：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">custom-input</span> <span class="attr">v-model</span>=<span class="string">&quot;searchText&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h2><hr>
<p>有的时候，在不同组件之间进行动态切换是非常有用的，比如在一个多标签的界面里切换组件，可以通过 Vue 的 <code>&lt;component&gt;</code> 元素加一个特殊的 <code>is</code> attribute 来实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;currentTabComponent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>currentTabComponent</code> 可以包括</p>
<ul>
<li>已注册组件的名字，或</li>
<li>一个组件的选项对象</li>
</ul>
<p>请留意，这个 attribute 可以用于常规 HTML 元素，但这些元素将被视为组件，这意味着所有的 attribute <strong>都会作为 DOM attribute 被绑定</strong>。对于像 <code>value</code> 这样的 property，若想让其如预期般工作，你需要使用 <code>.prop</code> 修饰器。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue可复用 &amp; 组合</title>
    <url>/2021/05/20/vue/4.%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7%20&amp;%20%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h1 id="Vue可复用-amp-组合"><a href="#Vue可复用-amp-组合" class="headerlink" title="Vue可复用 &amp; 组合"></a>Vue可复用 &amp; 组合</h1><span id="more"></span>
<hr>
<h1 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><hr>
<p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</p>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个混入对象</span></span><br><span class="line"><span class="keyword">var</span> myMixin = &#123;</span><br><span class="line">  <span class="attr">created</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.hello()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="attr">hello</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;hello from mixin!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个使用混入对象的组件</span></span><br><span class="line"><span class="keyword">var</span> Component = Vue.extend(&#123;</span><br><span class="line">  <span class="attr">mixins</span>: [myMixin]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> component = <span class="keyword">new</span> Component() <span class="comment">// =&gt; &quot;hello from mixin!&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="选项合并"><a href="#选项合并" class="headerlink" title="选项合并"></a>选项合并</h2><hr>
<p>当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。</p>
<p>比如，数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mixin = &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">      <span class="attr">foo</span>: <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">mixins</span>: [mixin],</span><br><span class="line">  <span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;goodbye&#x27;</span>,</span><br><span class="line">      <span class="attr">bar</span>: <span class="string">&#x27;def&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">created</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$data)</span><br><span class="line">    <span class="comment">// =&gt; &#123; message: &quot;goodbye&quot;, foo: &quot;abc&quot;, bar: &quot;def&quot; &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子<strong>之前</strong>调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mixin = &#123;</span><br><span class="line">  <span class="attr">created</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;混入对象的钩子被调用&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">mixins</span>: [mixin],</span><br><span class="line">  <span class="attr">created</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;组件钩子被调用&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; &quot;混入对象的钩子被调用&quot;</span></span><br><span class="line"><span class="comment">// =&gt; &quot;组件钩子被调用&quot;</span></span><br></pre></td></tr></table></figure>

<p>值为对象的选项，例如 <code>methods</code>、<code>components</code> 和 <code>directives</code>，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mixin = &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">conflicting</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;from mixin&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">mixins</span>: [mixin],</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="attr">bar</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">conflicting</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;from self&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.foo() <span class="comment">// =&gt; &quot;foo&quot;</span></span><br><span class="line">vm.bar() <span class="comment">// =&gt; &quot;bar&quot;</span></span><br><span class="line">vm.conflicting() <span class="comment">// =&gt; &quot;from self&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意：<code>Vue.extend()</code> 也使用同样的策略进行合并。</p>
<h2 id="全局混入"><a href="#全局混入" class="headerlink" title="全局混入"></a>全局混入</h2><hr>
<p>混入也可以进行全局注册。使用时格外小心！一旦使用全局混入，它将影响<strong>每一个</strong>之后创建的 Vue 实例。使用恰当时，这可以用来为自定义选项注入处理逻辑。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为自定义的选项 &#x27;myOption&#x27; 注入一个处理器。</span></span><br><span class="line">Vue.mixin(&#123;</span><br><span class="line">  <span class="attr">created</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myOption = <span class="built_in">this</span>.$options.myOption</span><br><span class="line">    <span class="keyword">if</span> (myOption) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(myOption)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">myOption</span>: <span class="string">&#x27;hello!&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// =&gt; &quot;hello!&quot;</span></span><br></pre></td></tr></table></figure>

<p>请谨慎使用全局混入，因为它会影响每个单独创建的 Vue 实例 (包括第三方组件)。大多数情况下，只应当应用于自定义选项，就像上面示例一样。推荐将其作为插件发布，以避免重复应用混入。</p>
<h2 id="自定义选项合并策略"><a href="#自定义选项合并策略" class="headerlink" title="自定义选项合并策略"></a>自定义选项合并策略</h2><hr>
<p>自定义选项将使用默认策略，即简单地覆盖已有值。如果想让自定义选项以自定义逻辑合并，可以向 <code>Vue.config.optionMergeStrategies</code> 添加一个函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.config.optionMergeStrategies.myOption = <span class="function"><span class="keyword">function</span> (<span class="params">toVal, fromVal</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回合并后的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于多数值为对象的选项，可以使用与 <code>methods</code> 相同的合并策略：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> strategies = Vue.config.optionMergeStrategies</span><br><span class="line">strategies.myOption = strategies.methods</span><br></pre></td></tr></table></figure>

<h1 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p>除了核心功能默认内置的指令 (<code>v-model</code> 和 <code>v-show</code>)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。</p>
<p>当页面加载时，该元素将获得焦点 (注意：<code>autofocus</code> 在移动版 Safari 上不工作)。事实上，只要你在打开这个页面后还没点击过任何内容，这个输入框就应当还是处于聚焦状态。现在让我们用指令来实现这个功能：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册一个全局自定义指令 `v-focus`</span></span><br><span class="line">Vue.directive(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">  <span class="attr">inserted</span>: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 聚焦元素</span></span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果想注册局部指令，组件中也接受一个 <code>directives</code> 的选项：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">  <span class="attr">focus</span>: &#123;</span><br><span class="line">    <span class="comment">// 指令的定义</span></span><br><span class="line">    <span class="attr">inserted</span>: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">      el.focus()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后你可以在模板中任何元素上使用新的 <code>v-focus</code> property，如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-focus</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p>
<ul>
<li><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li>
<li><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li>
<li><code>update</code>：所在组件的 VNode 更新时调用，<strong>但是可能发生在其子 VNode 更新之前</strong>。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</li>
</ul>
<p>我们会在稍后讨论渲染函数时介绍更多 VNodes 的细节。</p>
<ul>
<li><code>componentUpdated</code>：指令所在组件的 VNode <strong>及其子 VNode</strong> 全部更新后调用。</li>
<li><code>unbind</code>：只调用一次，指令与元素解绑时调用。</li>
</ul>
<p>接下来我们来看一下钩子函数的参数 (即 <code>el</code>、<code>binding</code>、<code>vnode</code> 和 <code>oldVnode</code>)。</p>
<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种：</p>
<ol>
<li>添加全局方法或者 property。如：<a href="https://github.com/karol-f/vue-custom-element">vue-custom-element</a></li>
<li>添加全局资源：指令/过滤器/过渡等。如 <a href="https://github.com/vuejs/vue-touch">vue-touch</a></li>
<li>通过全局混入来添加一些组件选项。如 <a href="https://github.com/vuejs/vue-router">vue-router</a></li>
<li>添加 Vue 实例方法，通过把它们添加到 <code>Vue.prototype</code> 上实现。</li>
<li>一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 <a href="https://github.com/vuejs/vue-router">vue-router</a></li>
</ol>
<h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><p>通过全局方法 <code>Vue.use()</code> 使用插件。它需要在你调用 <code>new Vue()</code> 启动应用之前完成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用 `MyPlugin.install(Vue)`</span></span><br><span class="line">Vue.use(MyPlugin)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...组件选项</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>也可以传入一个可选的选项对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.use(MyPlugin, &#123; <span class="attr">someOption</span>: <span class="literal">true</span> &#125;)</span><br></pre></td></tr></table></figure>

<p><code>Vue.use</code> 会自动阻止多次注册相同插件，届时即使多次调用也只会注册一次该插件。</p>
<p>Vue.js 官方提供的一些插件 (例如 <code>vue-router</code>) 在检测到 <code>Vue</code> 是可访问的全局变量时会自动调用 <code>Vue.use()</code>。然而在像 CommonJS 这样的模块环境中，你应该始终显式地调用 <code>Vue.use()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用 Browserify 或 webpack 提供的 CommonJS 模块环境时</span></span><br><span class="line"><span class="keyword">var</span> Vue = <span class="built_in">require</span>(<span class="string">&#x27;vue&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> VueRouter = <span class="built_in">require</span>(<span class="string">&#x27;vue-router&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要忘了调用此方法</span></span><br><span class="line">Vue.use(VueRouter)</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/vuejs/awesome-vue#components--libraries">awesome-vue</a> 集合了大量由社区贡献的插件和库。</p>
<h2 id="开发插件"><a href="#开发插件" class="headerlink" title="开发插件"></a>开发插件</h2><p>Vue.js 的插件应该暴露一个 <code>install</code> 方法。这个方法的第一个参数是 <code>Vue</code> 构造器，第二个参数是一个可选的选项对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MyPlugin.install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 添加全局方法或 property</span></span><br><span class="line">  Vue.myGlobalMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 添加全局资源</span></span><br><span class="line">  Vue.directive(<span class="string">&#x27;my-directive&#x27;</span>, &#123;</span><br><span class="line">    bind (el, binding, vnode, oldVnode) &#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 注入组件选项</span></span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    <span class="attr">created</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 添加实例方法</span></span><br><span class="line">  Vue.prototype.$myMethod = <span class="function"><span class="keyword">function</span> (<span class="params">methodOptions</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><p>Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：<strong>双花括号插值和 <code>v-bind</code> 表达式</strong> (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在双花括号中 --&gt;</span></span><br><span class="line">&#123;&#123; message | capitalize &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在 `v-bind` 中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;rawId | formatId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你可以在一个组件的选项中定义本地的过滤器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">filters: &#123;</span><br><span class="line">  <span class="attr">capitalize</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    value = value.toString()</span><br><span class="line">    <span class="keyword">return</span> value.charAt(<span class="number">0</span>).toUpperCase() + value.slice(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者在创建 Vue 实例之前全局定义过滤器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.filter(<span class="string">&#x27;capitalize&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  value = value.toString()</span><br><span class="line">  <span class="keyword">return</span> value.charAt(<span class="number">0</span>).toUpperCase() + value.slice(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当全局过滤器和局部过滤器重名时，会采用局部过滤器。</p>
<p>过滤器函数总接收表达式的值 (之前的操作链的结果) 作为第一个参数。在上述例子中，<code>capitalize</code> 过滤器函数将会收到 <code>message</code> 的值作为第一个参数。</p>
<p>过滤器可以串联：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;&#123; message | filterA | filterB &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>filterA</code> 被定义为接收单个参数的过滤器函数，表达式 <code>message</code> 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 <code>filterB</code>，将 <code>filterA</code> 的结果传递到 <code>filterB</code> 中。</p>
<p>过滤器是 JavaScript 函数，因此可以接收参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;&#123; message | filterA(<span class="string">&#x27;arg1&#x27;</span>, arg2) &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>这里，<code>filterA</code> 被定义为接收三个参数的过滤器函数。其中 <code>message</code> 的值作为第一个参数，普通字符串 <code>&#39;arg1&#39;</code> 作为第二个参数，表达式 <code>arg2</code> 的值作为第三个参数。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE组件通讯之——provide/inject</title>
    <url>/2021/03/02/vue/VUE%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF%E4%B9%8B%E2%80%94%E2%80%94provideinject/</url>
    <content><![CDATA[<h1 id="VUE组件通讯之——provide-inject"><a href="#VUE组件通讯之——provide-inject" class="headerlink" title="VUE组件通讯之——provide/inject"></a>VUE组件通讯之——provide/inject</h1><span id="more"></span>
<hr>
<h2 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1.使用方法"></a>1.使用方法</h2><p>现有一个这样结构的组件：组件A &gt; 组件B &gt; 组件C</p>
<h3 id="1-1-父组件（组件A）"><a href="#1-1-父组件（组件A）" class="headerlink" title="1.1 父组件（组件A）"></a>1.1 父组件（组件A）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> componentB <span class="keyword">from</span> <span class="string">&#x27;./componentB&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  	<span class="attr">components</span>: &#123;</span><br><span class="line">      componentB</span><br><span class="line">    &#125;,</span><br><span class="line">		<span class="function"><span class="title">provide</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      	<span class="keyword">return</span> &#123;</span><br><span class="line">      			<span class="attr">name</span>: <span class="built_in">this</span>.value</span><br><span class="line">    		&#125;	</span><br><span class="line">    &#125;,</span><br><span class="line">  	<span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  			<span class="keyword">return</span> &#123;</span><br><span class="line">          	<span class="attr">value</span>: <span class="string">&#x27;componmentA&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">		&#125;,</span><br><span class="line">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      	setTimeOut(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          	<span class="built_in">this</span>.value = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-子孙组件（组件C）"><a href="#1-2-子孙组件（组件C）" class="headerlink" title="1.2 子孙组件（组件C）"></a>1.2 子孙组件（组件C）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">		<span class="attr">inject</span>: [<span class="string">&#x27;name&#x27;</span>],</span><br><span class="line">  	<span class="attr">computed</span>: &#123;</span><br><span class="line">      	<span class="function"><span class="title">name</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          	<span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">      			<span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当在父组件使用了<code>provide</code>后，父组件会把<code>provide</code>变量<code>name</code>向子组件进行派发，也就是说这个父组件底下的所有子组件都能通过<code>inject</code>注入父组件派发的变量，而不用一层一层的进行传递。</p>
<ul>
<li>知识点：provide/inject 注入的数据是<u>不可响应</u>的，除非是一个可被监听的对象</li>
</ul>
<h2 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h2><p>每个工程化项目基本都有一个叫<code>AP.vue</code>的根组件，里面一般都是承载我们的根路由，并没有其他的东西，并且他通常是被<code>main.js</code>入口文件引入，作为根节点去出现的，所以并不会根据我们的路由切换而重新渲染，这时候我们就可以通过它来使用<code>provide</code>将<code>App.vue</code>整个实例作为一个对象派发出去，从而达到不使用vuex也能对全局数据进行管理的作用</p>
<h3 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a>App.vue</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">		<span class="function"><span class="title">provide</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      	<span class="keyword">return</span> &#123;</span><br><span class="line">          	<span class="attr">app</span>: <span class="built_in">this</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  	<span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      	<span class="attr">userName</span>: <span class="string">&#x27;xiaoming&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">  	<span class="attr">methods</span>: &#123;</span><br><span class="line">      	<span class="function"><span class="title">changeUserName</span>(<span class="params">userName</span>)</span>&#123;</span><br><span class="line">          	<span class="built_in">this</span>.userName = userName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Component-vue"><a href="#Component-vue" class="headerlink" title="Component.vue"></a>Component.vue</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">		<span class="attr">inject</span>: [<span class="string">&#x27;app&#x27;</span>],</span><br><span class="line">  	<span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      	<span class="built_in">console</span>.log(<span class="built_in">this</span>.app.userName)</span><br><span class="line">      	<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          	<span class="built_in">this</span>.app.changeUserName(<span class="string">&#x27;xiaohei&#x27;</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>这里的this就是当前App.vue的整个实例，而且是可响应的</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>组件通信</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue派发器思想</title>
    <url>/2021/07/19/vue/Vue%E6%B4%BE%E5%8F%91%E5%99%A8%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<h1 id="Vue派发器思想"><a href="#Vue派发器思想" class="headerlink" title="Vue派发器思想"></a>Vue派发器思想</h1><span id="more"></span>
<hr>
<h1 id="派发器结构"><a href="#派发器结构" class="headerlink" title="派发器结构"></a>派发器结构</h1><table>
<thead>
<tr>
<th>目录</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>actions</td>
<td>存储导出触发方法的名称</td>
</tr>
<tr>
<td>dispatch</td>
<td>存储导出派发器，后续的调用方法都通过他去完成</td>
</tr>
<tr>
<td>reducers</td>
<td>存储导出业务逻辑，所有的方法业务逻辑统一写到这里</td>
</tr>
</tbody></table>
<h1 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h1><p>导出需要触发事件的名称</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PLUS = <span class="string">&#x27;plus&#x27;</span>,</span><br><span class="line">      MINUS = <span class="string">&#x27;minus&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">			PLUS,</span><br><span class="line">  		MINUS</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="reducers"><a href="#reducers" class="headerlink" title="reducers"></a>reducers</h1><p>通过闭包将data给内部test函数使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="title">default</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">fail, value</span>)</span>&#123;</span><br><span class="line">    data[fail] = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    test</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;PLUS, MINUS&#125; = <span class="string">&#x27;@/actions&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reducers <span class="keyword">from</span> <span class="string">&#x27;reducers&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    test</span><br><span class="line">  &#125; = reducers(ctx.$data)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">type, ...args</span>)</span>&#123;</span><br><span class="line">    	<span class="keyword">switch</span>(type)&#123;</span><br><span class="line">        <span class="keyword">case</span> PLUS:</span><br><span class="line">          test(...args)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MINUS:</span><br><span class="line">          <span class="built_in">console</span>.log(MINUS);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中的环境变量</title>
    <url>/2021/11/15/vue/vue%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h1 id="Vue中的环境变量"><a href="#Vue中的环境变量" class="headerlink" title="Vue中的环境变量"></a>Vue中的环境变量</h1><span id="more"></span>
<hr>
<h1 id="env默认项"><a href="#env默认项" class="headerlink" title=".env默认项"></a><code>.env</code>默认项</h1><p>自定义的环境变量需要以<code>VUE_APP_</code>开头</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">NODE_ENV</span>: <span class="string">&#x27;production&#x27;</span>, <span class="comment">// &#x27;development&#x27;</span></span><br><span class="line">	<span class="attr">BASE_URL</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">VUE_APP_MY_NAME</span>: <span class="string">&#x27;XXX&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用环境变量"><a href="#使用环境变量" class="headerlink" title="使用环境变量"></a>使用环境变量</h1><p>config.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> env = prosess.env.NODE_ENV</span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">development</span>: &#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">production</span>: &#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">baseURL</span>: config[env].baseURL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>工程化</tag>
      </tags>
  </entry>
  <entry>
    <title>python-基础</title>
    <url>/2021/01/25/python/python%E7%AC%94%E8%AE%B01.24/</url>
    <content><![CDATA[<h1 id="python-基础"><a href="#python-基础" class="headerlink" title="python-基础"></a>python-基础</h1><span id="more"></span>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类似于java的Scanner</span></span><br><span class="line">title = <span class="built_in">input</span>(<span class="string">&quot;提示&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串 * 数字，相当于重复了十次</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-router</title>
    <url>/2021/03/05/vue/%E4%B8%80%E3%80%81%E8%B7%AF%E7%94%B1%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue-router"></a>Vue-router</h1><span id="more"></span>
<hr>
<h1 id="一、路由的概念与原理"><a href="#一、路由的概念与原理" class="headerlink" title="一、路由的概念与原理"></a>一、路由的概念与原理</h1><p>路由的本质就是对应关系，分为前端路由和后端路由</p>
<h1 id="二、Vue-router的基本使用步骤"><a href="#二、Vue-router的基本使用步骤" class="headerlink" title="二、Vue-router的基本使用步骤"></a>二、Vue-router的基本使用步骤</h1><h1 id="三、Vue-router的嵌套路由用法"><a href="#三、Vue-router的嵌套路由用法" class="headerlink" title="三、Vue-router的嵌套路由用法"></a>三、Vue-router的嵌套路由用法</h1><h1 id="四、Vue-router动态路由匹配用法"><a href="#四、Vue-router动态路由匹配用法" class="headerlink" title="四、Vue-router动态路由匹配用法"></a>四、Vue-router动态路由匹配用法</h1><h1 id="五、Vue-router命名路由用法"><a href="#五、Vue-router命名路由用法" class="headerlink" title="五、Vue-router命名路由用法"></a>五、Vue-router命名路由用法</h1><h1 id="六、Vue-router编程式导航用法"><a href="#六、Vue-router编程式导航用法" class="headerlink" title="六、Vue-router编程式导航用法"></a>六、Vue-router编程式导航用法</h1>]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
        <category>Vue-router</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title>MacBook M1使用webstorm配置SVN</title>
    <url>/2021/03/02/%E5%85%B6%E4%BB%96/MacBook%20M1%E4%BD%BF%E7%94%A8webstorm%E9%85%8D%E7%BD%AESVN/</url>
    <content><![CDATA[<h1 id="MacBook-M1使用webstorm配置SVN"><a href="#MacBook-M1使用webstorm配置SVN" class="headerlink" title="MacBook M1使用webstorm配置SVN"></a>MacBook M1使用webstorm配置SVN</h1><span id="more"></span>
<hr>
<h2 id="一、安装homebrew"><a href="#一、安装homebrew" class="headerlink" title="一、安装homebrew"></a>一、安装homebrew</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</span><br></pre></td></tr></table></figure>



<h2 id="二、安装SVN"><a href="#二、安装SVN" class="headerlink" title="二、安装SVN"></a>二、安装SVN</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install subversion </span><br></pre></td></tr></table></figure>

<h2 id="三、查看SVN安装的目录打开webstorm配置SVN"><a href="#三、查看SVN安装的目录打开webstorm配置SVN" class="headerlink" title="三、查看SVN安装的目录打开webstorm配置SVN"></a>三、查看SVN安装的目录打开webstorm配置SVN</h2><ol>
<li>先查看SVN环境变量执行的路径</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">which svn</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>拿到执行可执行文件路径后，输入命令行打开可执行文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open path</span><br></pre></td></tr></table></figure></li>
<li><p>打开可执行文件后在上面可看到SVN真正的安装路径</p>
<p>![image-20210302150138886](/Users/cenfuning/Library/Application Support/typora-user-images/image-20210302150138886.png)</p>
</li>
</ol>
<h2 id="四、打开webstorm配置SVN"><a href="#四、打开webstorm配置SVN" class="headerlink" title="四、打开webstorm配置SVN"></a>四、打开webstorm配置SVN</h2><ol>
<li><p>![image-20210302143610236](/Users/cenfuning/Library/Application Support/typora-user-images/image-20210302143610236.png)</p>
</li>
<li><p>粘贴上可执行文件的路径，记得顺便勾选上启用交互模式，方面后面使用SVN</p>
<p>![image-20210302143725777](/Users/cenfuning/Library/Application Support/typora-user-images/image-20210302143725777.png)</p>
</li>
</ol>
<h2 id="五、解决webstrom报错Some-errors-occurred-while-accessing-svn-working-copy-database的bug"><a href="#五、解决webstrom报错Some-errors-occurred-while-accessing-svn-working-copy-database的bug" class="headerlink" title="五、解决webstrom报错Some errors occurred while accessing svn working copy database的bug"></a>五、解决webstrom报错Some errors occurred while accessing svn working copy database的bug</h2><p>此时重启webstorm后可能会报这个错误，具体原因也不知道是什么，应该是webstorm的bug</p>
<p><img data-src="https://segmentfault.com/img/bVcO76w/view" alt="preview"></p>
<ol>
<li><p>去下载一个官方的补丁包，下载地址：</p>
<p><a href="https://repo1.maven.org/maven2/org/xerial/sqlite-jdbc/3.32.3.3/sqlite-jdbc-3.32.3.3.jar">https://repo1.maven.org/maven2/org/xerial/sqlite-jdbc/3.32.3.3/sqlite-jdbc-3.32.3.3.jar</a></p>
</li>
<li><p>将补丁包放置到webstorm下Contents/lib</p>
<p>![image-20210302151243871](/Users/cenfuning/Library/Application Support/typora-user-images/image-20210302151243871.png)</p>
</li>
<li><p>找到lib文件夹，把补丁放进去，重启webstorm就大功告成啦！</p>
<p>![image-20210302151344058](/Users/cenfuning/Library/Application Support/typora-user-images/image-20210302151344058.png)</p>
</li>
</ol>
<p>参考：</p>
<ul>
<li>[1] <a href="https://www.jianshu.com/p/9082f56c67ed">Mac新安装SVN</a></li>
<li>[2] <a href="https://www.cnblogs.com/liyihua/p/12753163.html">Mac 安装 brew</a></li>
<li>[3] <a href="https://ask.zol.com.cn/x/7174459.html">linux安装svn在哪个目录</a></li>
<li>[4] <a href="https://blog.csdn.net/hell_oword/article/details/113182301?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&dist_request_id=1328575.10320.16146655223639245&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">CSND-Macbook m1环境配置终极版</a></li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>SVN</tag>
        <tag>其他</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown的使用方法</title>
    <url>/2019/04/27/%E5%85%B6%E4%BB%96/MarkDown%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="MarkDown使用方法"><a href="#MarkDown使用方法" class="headerlink" title="MarkDown使用方法"></a>MarkDown使用方法</h1><span id="more"></span>
<hr>
<h1 id="“-”是一级标题"><a href="#“-”是一级标题" class="headerlink" title="“# ”是一级标题"></a>“# ”是一级标题</h1><h2 id="“-”是二级标题"><a href="#“-”是二级标题" class="headerlink" title="“## ”是二级标题"></a>“## ”是二级标题</h2><h3 id="“-”是三级标题"><a href="#“-”是三级标题" class="headerlink" title="“### ”是三级标题"></a>“### ”是三级标题</h3><ul>
<li>“- ”是列表<br>  a “a ”是子列表</li>
</ul>
<hr>
<p><a href="https://www.bilibili.com/video/av17653359/?p=11">参考文献</a></p>
<hr>
<h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello!world"></a>hello!world</h2><p><img data-src="https://s2.ax1x.com/2019/04/27/EuVfBV.md.jpg" alt="插入图片"></p>
<p><em>斜体字</em></p>
<p><strong>粗体字</strong></p>
<p><code>&lt;h1&gt;单行代码格式&lt;/h1&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;h1&gt;多行代码格式&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>分享 - markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo个人博客搭建</title>
    <url>/2021/03/01/%E5%85%B6%E4%BB%96/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="Hexo个人博客搭建"><a href="#Hexo个人博客搭建" class="headerlink" title="Hexo个人博客搭建"></a>Hexo个人博客搭建</h1><span id="more"></span>
<hr>
<h2 id="一、项目搭建-amp-初始化"><a href="#一、项目搭建-amp-初始化" class="headerlink" title="一、项目搭建&amp;初始化"></a>一、项目搭建&amp;初始化</h2><p>安装hexo框架</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>初始化hexo项目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init hexo</span><br></pre></td></tr></table></figure>

<p>安装项目依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>项目目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml  网站的配置信息，网页的大部分的参数在此配置。</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source       资源文件夹，是存放资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes       主题 文件夹。Hexo 会根据主题来生成静态页面。</span><br></pre></td></tr></table></figure>

<p>运行项目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<h2 id="二、装修页面（换主题）"><a href="#二、装修页面（换主题）" class="headerlink" title="二、装修页面（换主题）"></a>二、装修页面（换主题）</h2><p>先去hexo官网的主题去找一个喜欢的主题，然后通过git clone到项目的跟目录下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-theme-next@latest </span><br></pre></td></tr></table></figure>

<p>安装好后找到根目录下的<code>_config.yml</code>文件，找到<code>theme</code>配置，修改为<code>next</code>，然后就根据next官网的配置去改就好</p>
<h2 id="三、引入动态背景"><a href="#三、引入动态背景" class="headerlink" title="三、引入动态背景"></a>三、引入动态背景</h2><p>参考canvas-nest官网</p>
<h2 id="四、设置加载进度"><a href="#四、设置加载进度" class="headerlink" title="四、设置加载进度"></a>四、设置加载进度</h2><p>参考</p>
<ul>
<li><p>[2] <a href="https://hexo.io/zh-cn/docs/index.html">hexo官网</a></p>
</li>
<li><p>[2] <a href="https://theme-next.js.org/docs/getting-started/">NEXT官网</a></p>
</li>
<li><p>[3] <a href="https://github.com/theme-next/theme-next-canvas-nest">canvas-nest</a></p>
</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
        <tag>分享</tag>
        <tag>hexo</tag>
        <tag>个人博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown语法</title>
    <url>/2022/01/08/%E5%85%B6%E4%BB%96/MarkDown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p><strong>MarkDown语法</strong></p>
<span id="more"></span>
<hr>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">MarkDown语法</span><br><span class="line"></span><br><span class="line"><span class="section">标题</span></span><br><span class="line"><span class="section">---------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">样式</span></span><br><span class="line"><span class="section">---------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="emphasis">*斜体*</span> </span><br><span class="line"></span><br><span class="line"><span class="strong">**粗体**</span> </span><br><span class="line"></span><br><span class="line">==高亮==</span><br><span class="line"></span><br><span class="line">~~删除线~~</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 引用</span></span><br><span class="line"></span><br><span class="line">H~2~O 下标</span><br><span class="line"></span><br><span class="line">2^10^ 上标</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">列表</span></span><br><span class="line"><span class="section">---------------------------</span></span><br><span class="line"></span><br><span class="line">无序列表</span><br><span class="line"><span class="bullet">-</span> Item</span><br><span class="line"><span class="bullet">  *</span> Item</span><br><span class="line"><span class="bullet">    +</span> Item</span><br><span class="line"></span><br><span class="line">有序列表</span><br><span class="line"><span class="bullet">1.</span> Item 1</span><br><span class="line"><span class="bullet">2.</span> Item 2</span><br><span class="line"><span class="bullet">3.</span> Item 3</span><br><span class="line"></span><br><span class="line">待办列表:</span><br><span class="line"><span class="bullet">-</span> [ ] Incomplete item</span><br><span class="line"><span class="bullet">-</span> [x] Complete item</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">链接</span></span><br><span class="line"><span class="section">---------------------------</span></span><br><span class="line"></span><br><span class="line">A [<span class="string">link</span>](<span class="link">http://example.com</span>).文字链接</span><br><span class="line"></span><br><span class="line">An image: ![<span class="string">Alt</span>](<span class="link">img.jpg</span>)图片链接</span><br><span class="line"></span><br><span class="line">A sized image: ![<span class="string">Alt</span>](<span class="link">img.jpg =60x50</span>)固定大小的图片</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">代码</span></span><br><span class="line"><span class="section">---------------------------</span></span><br><span class="line"></span><br><span class="line">单行代码</span><br><span class="line">Some <span class="code">`inline code`</span>.</span><br><span class="line"></span><br><span class="line">代码块</span><br><span class="line"><span class="code">```</span></span><br><span class="line"><span class="code">// A code block</span></span><br><span class="line"><span class="code">var foo = &#x27;bar&#x27;;</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"></span><br><span class="line">语言标注</span><br><span class="line"><span class="code">```javascript</span></span><br><span class="line"><span class="code">// An highlighted block</span></span><br><span class="line"><span class="code">var foo = &#x27;bar&#x27;;</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">表格</span></span><br><span class="line"><span class="section">---------------------------</span></span><br><span class="line"></span><br><span class="line">Item     | Value</span><br><span class="line">-------- | -----</span><br><span class="line">Computer | $1600</span><br><span class="line">Phone    | $12</span><br><span class="line">Pipe     | $1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">| Column 1 | Column 2      |</span><br><span class="line">|:--------:| -------------:|</span><br><span class="line">| centered | right-aligned |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">自定义列表</span></span><br><span class="line"><span class="section">--------</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
        <tag>分享</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>应用常用命令行总汇</title>
    <url>/2021/04/12/%E5%85%B6%E4%BB%96/%E5%BA%94%E7%94%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%80%BB%E6%B1%87/</url>
    <content><![CDATA[<h1 id="应用常用命令行总汇"><a href="#应用常用命令行总汇" class="headerlink" title="应用常用命令行总汇"></a>应用常用命令行总汇</h1><span id="more"></span>
<hr>
<h2 id="1-检测mac硬盘读取写入量"><a href="#1-检测mac硬盘读取写入量" class="headerlink" title="1. 检测mac硬盘读取写入量"></a>1. 检测mac硬盘读取写入量</h2><h3 id="打开S-M-A-R-T监控"><a href="#打开S-M-A-R-T监控" class="headerlink" title="打开S.M.A.R.T监控"></a>打开S.M.A.R.T监控</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">smartctl -s on disk0</span><br></pre></td></tr></table></figure>

<h3 id="命令查看状态"><a href="#命令查看状态" class="headerlink" title="命令查看状态"></a>命令查看状态</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">smartctl -a disk0</span><br></pre></td></tr></table></figure>

<h2 id="2-git"><a href="#2-git" class="headerlink" title="2. git"></a>2. git</h2><h3 id="拉取远程分支内容"><a href="#拉取远程分支内容" class="headerlink" title="拉取远程分支内容"></a>拉取远程分支内容</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch --all</span><br></pre></td></tr></table></figure>

<h3 id="覆盖本地master分支"><a href="#覆盖本地master分支" class="headerlink" title="覆盖本地master分支"></a>覆盖本地master分支</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard master</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>其他</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序云开发</title>
    <url>/2021/03/15/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="微信小程序云开发"><a href="#微信小程序云开发" class="headerlink" title="微信小程序云开发"></a>微信小程序云开发</h1><span id="more"></span>
<hr>
<h2 id="1-初始化云开发"><a href="#1-初始化云开发" class="headerlink" title="1. 初始化云开发"></a>1. 初始化云开发</h2><p><code>app.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">App(&#123;</span><br><span class="line">  <span class="attr">onLaunch</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!wx.cloud) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">&#x27;请使用 2.2.3 或以上的基础库以使用云能力&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      wx.cloud.init(&#123;</span><br><span class="line">        <span class="comment">// env 参数说明：</span></span><br><span class="line">        <span class="comment">//   env 参数决定接下来小程序发起的云开发调用（wx.cloud.xxx）会默认请求到哪个云环境的资源</span></span><br><span class="line">        <span class="comment">//   此处请填入环境 ID, 环境 ID 可打开云控制台查看</span></span><br><span class="line">        <span class="comment">//   如不填则使用默认环境（第一个创建的环境）</span></span><br><span class="line">        <span class="attr">env</span>: <span class="string">&#x27;wecloud-demo-01&#x27;</span>,</span><br><span class="line">        <span class="attr">traceUser</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.globalData = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="2-查询数据表数据"><a href="#2-查询数据表数据" class="headerlink" title="2. 查询数据表数据"></a>2. 查询数据表数据</h2><h3 id="2-1-新建数据表"><a href="#2-1-新建数据表" class="headerlink" title="2-1 新建数据表"></a>2-1 新建数据表</h3><h3 id="2-2-查找数据表"><a href="#2-2-查找数据表" class="headerlink" title="2-2 查找数据表"></a>2-2 查找数据表</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> collection = wx.cloud.database().collection(<span class="string">&#x27;cloundDevelopment&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-3-修改数据库操作权限"><a href="#2-3-修改数据库操作权限" class="headerlink" title="2-3 修改数据库操作权限"></a>2-3 修改数据库操作权限</h3><p>![image-20210315012355149](/Users/cenfuning/Library/Application Support/typora-user-images/image-20210315012355149.png)</p>
<h3 id="2-4-查找数据表内数据"><a href="#2-4-查找数据表内数据" class="headerlink" title="2-4 查找数据表内数据"></a>2-4 查找数据表内数据</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">collection.get().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-5-条件查询"><a href="#2-5-条件查询" class="headerlink" title="2-5 条件查询"></a>2-5 条件查询</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">collection.where(&#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;).get().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-6-单条数据查询（必填-id）"><a href="#2-6-单条数据查询（必填-id）" class="headerlink" title="2-6 单条数据查询（必填_id）"></a>2-6 单条数据查询（必填_id）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">collection.doc(&#123;</span><br><span class="line">	<span class="attr">_id</span>: <span class="string">&#x27;xxxxx&#x27;</span> <span class="comment">//必填</span></span><br><span class="line">&#125;).get().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-7-数据排序（asc-desc）"><a href="#2-7-数据排序（asc-desc）" class="headerlink" title="2-7 数据排序（asc/desc）"></a>2-7 数据排序（asc/desc）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">collection.orderBy(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;asc&#x27;</span>).get().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-8-限制返回数据条数"><a href="#2-8-限制返回数据条数" class="headerlink" title="2-8 限制返回数据条数"></a>2-8 限制返回数据条数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">collection.limit(<span class="number">10</span>).get().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-9-从第几条数据开始返回"><a href="#2-9-从第几条数据开始返回" class="headerlink" title="2-9 从第几条数据开始返回"></a>2-9 从第几条数据开始返回</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">collection</span><br><span class="line">  .limit(<span class="number">10</span>)</span><br><span class="line">	.skip(<span class="number">1</span>)</span><br><span class="line">	.get()</span><br><span class="line">	.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(res)</span><br><span class="line">	&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(res)</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="3-添加数据表数据"><a href="#3-添加数据表数据" class="headerlink" title="3. 添加数据表数据"></a>3. 添加数据表数据</h2><h3 id="3-1-添加数据"><a href="#3-1-添加数据" class="headerlink" title="3-1 添加数据"></a>3-1 添加数据</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">collection.add(&#123;</span><br><span class="line">	<span class="attr">data</span>: &#123;</span><br><span class="line">		<span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="4-修改数据表数据"><a href="#4-修改数据表数据" class="headerlink" title="4. 修改数据表数据"></a>4. 修改数据表数据</h2><h3 id="4-1-修改单条数据"><a href="#4-1-修改单条数据" class="headerlink" title="4-1 修改单条数据"></a>4-1 修改单条数据</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">collection.doc(&#123;</span><br><span class="line">  <span class="attr">_id</span>: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">&#125;).update(&#123;</span><br><span class="line">	<span class="attr">data</span>: &#123;</span><br><span class="line">		<span class="attr">name</span>: <span class="string">&#x27;小红&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="5-删除数据表数据"><a href="#5-删除数据表数据" class="headerlink" title="5. 删除数据表数据"></a>5. 删除数据表数据</h2><h3 id="5-1-删除单条数据"><a href="#5-1-删除单条数据" class="headerlink" title="5-1 删除单条数据"></a>5-1 删除单条数据</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">collection.doc(&#123;</span><br><span class="line">  <span class="attr">_id</span>: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">&#125;).remove().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="6-command"><a href="#6-command" class="headerlink" title="6. command"></a>6. command</h2><p>*<a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/database/Command.html">command</a></p>
<h3 id="6-1-实例化对象"><a href="#6-1-实例化对象" class="headerlink" title="6-1 实例化对象"></a>6-1 实例化对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = wx.cloud.database().command</span><br></pre></td></tr></table></figure>

<h3 id="6-2-查询大-小于-大于等于-小于等于某个数的数据（gt-gte-lt-lte）"><a href="#6-2-查询大-小于-大于等于-小于等于某个数的数据（gt-gte-lt-lte）" class="headerlink" title="6-2 查询大/小于/大于等于/小于等于某个数的数据（gt/gte/lt/lte）"></a>6-2 查询大/小于/大于等于/小于等于某个数的数据（gt/gte/lt/lte）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">collection.where(&#123;</span><br><span class="line">	<span class="attr">age</span>: _.gt(<span class="number">18</span>)</span><br><span class="line">&#125;).get().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="6-3-查询某个范围的数值的数据"><a href="#6-3-查询某个范围的数值的数据" class="headerlink" title="6-3 查询某个范围的数值的数据"></a>6-3 查询某个范围的数值的数据</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">collection.where(_.and([&#123;</span><br><span class="line">	<span class="attr">age</span>: _.gt(<span class="number">18</span>)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">	<span class="attr">age</span>: _.lte(<span class="number">35</span>)</span><br><span class="line">&#125;]))</span><br><span class="line">	.get().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(res)</span><br><span class="line">	&#125;)</span><br><span class="line">	.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(res)</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>前端</category>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>微信小程序云开发</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2021/10/04/JavaScript/Promise/</url>
    <content><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><span id="more"></span>
<hr>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>万金油reduce的 9 种使用场景</title>
    <url>/2021/09/15/JavaScript/%E4%B8%87%E9%87%91%E6%B2%B9reduce%E7%9A%84%209%20%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h1 id="万金油reduce的-9-种使用场景"><a href="#万金油reduce的-9-种使用场景" class="headerlink" title="万金油reduce的 9 种使用场景"></a>万金油reduce的 9 种使用场景</h1><span id="more"></span>
<hr>
<h2 id="1-数组求和"><a href="#1-数组求和" class="headerlink" title="1. 数组求和"></a>1. 数组求和</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// sum is 6</span></span><br></pre></td></tr></table></figure>

<h2 id="2-数组成员为对象时求和"><a href="#2-数组成员为对象时求和" class="headerlink" title="2. 数组成员为对象时求和"></a>2. 数组成员为对象时求和</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = [&#123;<span class="attr">value</span>: <span class="number">0</span>&#125;, &#123;<span class="attr">value</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">value</span>: <span class="number">2</span>&#125;, &#123;<span class="attr">value</span>: <span class="number">3</span>&#125;].reduceRight(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> accumulator + currentValue.value);</span><br><span class="line"><span class="comment">// sum is 6</span></span><br></pre></td></tr></table></figure>

<h2 id="3-将二维数组转化为一维数组"><a href="#3-将二维数组转化为一维数组" class="headerlink" title="3. 将二维数组转化为一维数组"></a>3. 将二维数组转化为一维数组</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]].reduceRight(</span><br><span class="line">  <span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> accumulator.concat(currentValue) currentValue.value, </span><br><span class="line">	[]</span><br><span class="line">);</span><br><span class="line"><span class="comment">// sum is [1, 2, 3, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure>

<h2 id="4-计算数组中每个元素出现的次数"><a href="#4-计算数组中每个元素出现的次数" class="headerlink" title="4. 计算数组中每个元素出现的次数"></a>4. 计算数组中每个元素出现的次数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduceRight(</span><br><span class="line">  <span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> &#123;</span><br><span class="line">  	<span class="keyword">if</span>(currentValue <span class="keyword">in</span> accumulator)&#123;</span><br><span class="line">  		accumulator[currentValue]++;</span><br><span class="line">  	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  		accumulator[name] = <span class="number">1</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> accumulator</span><br><span class="line">  &#125;, </span><br><span class="line">	&#123;&#125;</span><br><span class="line">);</span><br><span class="line">&lt;!-- sum is &#123;</span><br><span class="line">	<span class="number">1</span>: <span class="number">2</span>,</span><br><span class="line">	<span class="number">2</span>: <span class="number">2</span>,</span><br><span class="line">	<span class="number">3</span>: <span class="number">2</span>,</span><br><span class="line">	<span class="number">4</span>: <span class="number">1</span>,</span><br><span class="line">	<span class="number">5</span>: <span class="number">2</span>,</span><br><span class="line">	<span class="number">6</span>: <span class="number">1</span></span><br><span class="line">&#125; --&gt;</span><br></pre></td></tr></table></figure>

<h2 id="5-按对象属性对obj分类"><a href="#5-按对象属性对obj分类" class="headerlink" title="5. 按对象属性对obj分类"></a>5. 按对象属性对obj分类</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> people = [&#123;<span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>: <span class="string">&#x27;21&#x27;</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span>, <span class="attr">age</span>: <span class="string">&#x27;22&#x27;</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">&#x27;王五&#x27;</span>, <span class="attr">age</span>: <span class="string">&#x27;21&#x27;</span>&#125;];</span><br><span class="line"><span class="keyword">var</span> sum = people.reduce(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> key = currentValue.name;</span><br><span class="line">  <span class="keyword">if</span>(!accumulator[key])&#123;</span><br><span class="line">    accumulator[key] = [];</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    accumulator[key].push(currentValue)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> accumulator</span><br><span class="line">&#125;, &#123;&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="6-数组去重"><a href="#6-数组去重" class="headerlink" title="6. 数组去重"></a>6. 数组去重</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr.sort().reduce(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(accumulator.length === <span class="number">0</span> || accumulator[accumulator.length - <span class="number">1</span>] !== currentValue)&#123;</span><br><span class="line">    accumulator.push(currentValue)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> accumulator</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure>

<h2 id="7-按序运行promise"><a href="#7-按序运行promise" class="headerlink" title="7. 按序运行promise"></a>7. 按序运行promise</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runPromiseInSequence</span>(<span class="params">arr, input</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(</span><br><span class="line">    <span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> accumulator.then(currentValue),</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(input)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>原生AJAX</title>
    <url>/2021/11/19/JavaScript/AJAX/</url>
    <content><![CDATA[<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><span id="more"></span>
<hr>
<h1 id="Asynchronous-JavaScript-and-XML"><a href="#Asynchronous-JavaScript-and-XML" class="headerlink" title="Asynchronous JavaScript and XML"></a>Asynchronous JavaScript and XML</h1><p>异步的JavaScript和XML</p>
<h2 id="一、实例化AJAX"><a href="#一、实例化AJAX" class="headerlink" title="一、实例化AJAX"></a>一、实例化AJAX</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">  xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  xhr = ActiveXObject(<span class="string">&#x27;Microsoft.XMLHTTP&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、setRequestHeader"><a href="#二、setRequestHeader" class="headerlink" title="二、setRequestHeader"></a>二、setRequestHeader</h2><p> 向请求添加 HTTP 头</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	xhr.setRequestHeader(header, value)</span></span><br><span class="line"><span class="comment">	@header: 规定头的名称</span></span><br><span class="line"><span class="comment">	@value: 规定头的值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="二、请求"><a href="#二、请求" class="headerlink" title="二、请求"></a>二、请求</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	xhr.open(method: string, url: string, async: boolean)</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	@method: 请求的类型；GET 或 POST</span></span><br><span class="line"><span class="comment">	@url: 文件在服务器上的位置</span></span><br><span class="line"><span class="comment">	@async: true（异步）或 false（同步）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GET请求</span></span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://xxxxxx&#x27;</span>, <span class="literal">true</span>) </span><br><span class="line">xhr.send()</span><br><span class="line"></span><br><span class="line"><span class="comment">// POST请求</span></span><br><span class="line">xhr.open(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;http://xxxxxx&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// post请求方式必须设置这个请求头信息，目的是请求体中的数据格式转换为键值对，这样后端接收到key=value这样的数据才知道这是一个POST方式传来的数据</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">&quot;Content-type&quot;</span>,<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">xhr.send(<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;value&#125;</span>`</span>)</span><br></pre></td></tr></table></figure>

<h2 id="三、响应"><a href="#三、响应" class="headerlink" title="三、响应"></a>三、响应</h2><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>responseText</td>
<td>获得字符串形式的响应数据。</td>
</tr>
<tr>
<td>responseXML</td>
<td>获得 XML 形式的响应数据。</td>
</tr>
</tbody></table>
<h2 id="四、readystate"><a href="#四、readystate" class="headerlink" title="四、readystate"></a>四、readystate</h2><p>readyState状态，通过XMLRequest对象发送HTTP请求的各阶段状态码（0-4），当readyState变化时（2、3、4），将触发onreadystatechange事件执行其回调函数</p>
<ul>
<li>0: 请求未初始化</li>
<li>1: 服务器连接已建立</li>
<li>2: 请求已接收</li>
<li>3: 请求处理中</li>
<li>4: 请求已完成，且响应已就绪</li>
</ul>
<p><em><strong>注意: readyState仅仅是针对请求与响应的状态码，获取资源是否成功取决于status的状态</strong></em></p>
<h2 id="五、status"><a href="#五、status" class="headerlink" title="五、status"></a>五、status</h2><ul>
<li>200: “OK”</li>
<li>404: 未找到页面</li>
</ul>
<h2 id="六、onreadystatechange"><a href="#六、onreadystatechange" class="headerlink" title="六、onreadystatechange"></a>六、onreadystatechange</h2><p>存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。</p>
<h2 id="七、其他"><a href="#七、其他" class="headerlink" title="七、其他"></a>七、其他</h2><ul>
<li>xhr.onload: 请求成功时调用</li>
<li>Xhr.onerror: 请求失败时调用</li>
</ul>
<h2 id="八、完整实例"><a href="#八、完整实例" class="headerlink" title="八、完整实例"></a>八、完整实例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">  xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  xhr = ActiveXObject(<span class="string">&#x27;Microsoft.XMLHTTP&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(xhr.readystate)</span><br><span class="line"><span class="comment">// ------------ readystate -&gt; 0 ------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GET请求</span></span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://xxxxxx&#x27;</span>, <span class="literal">true</span>) <span class="comment">// 异步</span></span><br><span class="line">xhr.send()</span><br><span class="line"><span class="comment">// POST请求</span></span><br><span class="line">xhr.open(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;http://xxxxxx&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.setRequestHeader(<span class="string">&quot;Content-type&quot;</span>,<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">xhr.send(<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line"><span class="built_in">console</span>.log(xhr.readystate)</span><br><span class="line"><span class="comment">// ------------ readystate -&gt; 1 ------------</span></span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(xhr.readystate) <span class="comment">// readystate -&gt; 2、3、4</span></span><br><span class="line">  <span class="keyword">if</span> (xhr.readystate === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;请求成功&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;获取字符串数据: &#x27;</span>, xhr.responenseText);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;获取XML数据: &#x27;</span>, xhr.responenseXML)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// onload 和 onerror 属性都是函数，分别在它请求成功和请求失败时被调用。</span></span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">xhr.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>uniapp之——高德获取定位</title>
    <url>/2021/03/02/uniapp/uniapp%E4%B9%8B%E2%80%94%E2%80%94%E9%AB%98%E5%BE%B7%E8%8E%B7%E5%8F%96%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<h1 id="uniapp之——高德获取定位"><a href="#uniapp之——高德获取定位" class="headerlink" title="uniapp之——高德获取定位"></a>uniapp之——高德获取定位</h1><p>首先，强调！！！打包的时候，一定把配置文件里面定位的模块给勾选上，如果你用了地图组件就勾组件，只是用了定位就勾定位，没有勾选上的话只要调试基座能够获取到定位，打包后是获取不到的。</p>
<span id="more"></span>
<hr>
<h2 id="一、注册高德账号，开通申请WebAPI的key值"><a href="#一、注册高德账号，开通申请WebAPI的key值" class="headerlink" title="一、注册高德账号，开通申请WebAPI的key值"></a>一、注册高德账号，开通申请WebAPI的key值</h2><p><img data-src="https://img.imgdb.cn/item/603e4212360785be5452bdcd.png" alt="1"></p>
<p><img data-src="https://img.imgdb.cn/item/603e4239360785be5452d0cb.png" alt="2"></p>
<p><img data-src="https://img.imgdb.cn/item/603e42bd360785be54530c43.png" alt="3"></p>
<h2 id="二、代码案例"><a href="#二、代码案例" class="headerlink" title="二、代码案例"></a>二、代码案例</h2>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//思路：利用uni.getLocation获取经纬度定位，再用高德的webAPI将经纬度你解析成地址</span><br><span class="line">uni.getLocation(&#123;</span><br><span class="line">	success(res)&#123;</span><br><span class="line">		console.log(&quot;res: &quot;, res)</span><br><span class="line">		uni.request(&#123;</span><br><span class="line">			url: `https://restapi.amap.com/v3/geocode/regeo?key=你的webAPIkey值&amp;location=$&#123;res.longitude&#125;,$&#123;res.latitude&#125;`,</span><br><span class="line">			success(res)&#123;</span><br><span class="line">				console.log(res)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;,</span><br><span class="line">	fail(err)&#123;</span><br><span class="line">		uni.showModal(&#123;</span><br><span class="line">			title:`定位失败：$&#123;JSON.stringify(err)&#125;`,</span><br><span class="line">			icon: &#x27;none&#x27;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="三、申请安卓应用的key值"><a href="#三、申请安卓应用的key值" class="headerlink" title="三、申请安卓应用的key值"></a>三、申请安卓应用的key值</h2><p><img data-src="https://img.imgdb.cn/item/603e434d360785be5453550a.png" alt="5"></p>
<p><img data-src="https://img.imgdb.cn/item/603e4377360785be54536c43.png" alt="6"></p>
<p>3.1 获取PackageName（别名和Android包名一致）</p>
<p><img data-src="https://img.imgdb.cn/item/603e431e360785be54533d9a.png" alt="4"></p>
<h2 id="三、生成Android签名证书-amp-获取HSA1"><a href="#三、生成Android签名证书-amp-获取HSA1" class="headerlink" title="三、生成Android签名证书 &amp; 获取HSA1"></a>三、生成Android签名证书 &amp; 获取HSA1</h2><p>先安装JavaJDK，再进入命令行工具</p>
<p>调试版本使用 debug.keystore，命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keytool -list -v -keystore debug.keystore</span><br></pre></td></tr></table></figure>

<p> 发布版本使用 apk 对应的 keystore，命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keytool -list -v -keystore apk的keystore</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keytool -genkey -alias testalias -keyalg RSA -keysize 2048 -validity 36500 -keystore test.keystore</span><br></pre></td></tr></table></figure>

<ul>
<li>testalias是证书别名，可修改为自己想设置的字符，建议使用英文字母和数字</li>
<li>test.keystore是证书文件名称，可修改为自己想设置的文件名称，也可以指定完整文件路径</li>
</ul>
<p>回车后会提示：</p>
<ul>
<li>提示输入密钥库密码，调试版本默认密码是 android，发布版本的密码是为 apk 的 keystore 设置的密码。输入密钥后回车（如果没设置密码，可直接回车），此时可在控制台显示的信息中获取 SHA1 值，如下图所示：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enter keystore password:  //输入证书文件密码，输入完成回车  </span><br><span class="line">Re-enter new password:   //再次输入证书文件密码，输入完成回车  </span><br><span class="line">What is your first and last name?  </span><br><span class="line">  [Unknown]:  //输入名字和姓氏，输入完成回车  </span><br><span class="line">What is the name of your organizational unit?  </span><br><span class="line">  [Unknown]:  //输入组织单位名称，输入完成回车  </span><br><span class="line">What is the name of your organization?  </span><br><span class="line">  [Unknown]:  //输入组织名称，输入完成回车  </span><br><span class="line">What is the name of your City or Locality?  </span><br><span class="line">  [Unknown]:  //输入城市或区域名称，输入完成回车  </span><br><span class="line">What is the name of your State or Province?  </span><br><span class="line">  [Unknown]:  //输入省/市/自治区名称，输入完成回车  </span><br><span class="line">What is the two-letter country code for this unit?  </span><br><span class="line">  [Unknown]:  //输入国家/地区代号（两个字母），中国为CN，输入完成回车  </span><br><span class="line">Is CN=XX, OU=XX, O=XX, L=XX, ST=XX, C=XX correct?  </span><br><span class="line">  [no]:  //确认上面输入的内容是否正确，输入y，回车  </span><br><span class="line"></span><br><span class="line">Enter key password for &lt;testalias&gt;  </span><br><span class="line">        (RETURN if same as keystore password):  //确认证书密码与证书文件密码一样（HBuilder|HBuilderX要求这两个密码一致），直接回车就可以</span><br></pre></td></tr></table></figure>

<p>以上命令运行完成后就会生成证书，文件名为<code>test.keystore</code>。</p>
<p><strong>注意：上述信息填写要规范，乱填有可能会影响应用上架应用市场。</strong></p>
<h3 id="查看证书信息"><a href="#查看证书信息" class="headerlink" title="查看证书信息"></a>查看证书信息</h3><p>可以使用以下命令查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keytool -list -v -keystore test.keystore  </span><br><span class="line">Enter keystore password: //输入密码，回车</span><br></pre></td></tr></table></figure>

<p>会输出以下格式信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">复制代码Keystore type: PKCS12    </span><br><span class="line">Keystore provider: SUN    </span><br><span class="line"></span><br><span class="line">Your keystore contains 1 entry    </span><br><span class="line"></span><br><span class="line">Alias name: test    </span><br><span class="line">Creation date: 2019-10-28    </span><br><span class="line">Entry type: PrivateKeyEntry    </span><br><span class="line">Certificate chain length: 1    </span><br><span class="line">Certificate[1]:    </span><br><span class="line">Owner: CN=Tester, OU=Test, O=Test, L=HD, ST=BJ, C=CN    </span><br><span class="line">Issuer: CN=Tester, OU=Test, O=Test, L=HD, ST=BJ, C=CN    </span><br><span class="line">Serial number: 7dd12840    </span><br><span class="line">Valid from: Fri Jul 26 20:52:56 CST 2019 until: Sun Jul 02 20:52:56 CST 2119    </span><br><span class="line">Certificate fingerprints:    </span><br><span class="line">         MD5:  F9:F6:C8:1F:DB:AB:50:14:7D:6F:2C:4F:CE:E6:0A:A5    </span><br><span class="line">         SHA1: BB:AC:E2:2F:97:3B:18:02:E7:D6:69:A3:7A:28:EF:D2:3F:A3:68:E7    </span><br><span class="line">         SHA256: 24:11:7D:E7:36:12:BC:FE:AF:2A:6A:24:BD:04:4F:2E:33:E5:2D:41:96:5F:50:4D:74:17:7F:4F:E2:55:EB:26    </span><br><span class="line">Signature algorithm name: SHA256withRSA    </span><br><span class="line">Subject Public Key Algorithm: 2048-bit RSA key    </span><br><span class="line">Version: 3</span><br></pre></td></tr></table></figure>

<p>其中证书指纹信息（Certificate fingerprints）：</p>
<ul>
<li>MD5<br>证书的MD5指纹信息（安全码MD5）</li>
<li>SHA1<br>证书的SHA1指纹信息（安全码SHA1）</li>
<li>SHA256<br>证书的SHA256指纹信息（安全码SHA245）</li>
</ul>
<h2 id="五、打包模块配置"><a href="#五、打包模块配置" class="headerlink" title="五、打包模块配置"></a>五、打包模块配置</h2><p><img data-src="https://img.imgdb.cn/item/603e43a3360785be5453833b.png" alt="7"></p>
<p>appkey用从高德申请到的。</p>
<h2 id="六、打包"><a href="#六、打包" class="headerlink" title="六、打包"></a>六、打包</h2><ol>
<li>Andriond包名要和刚刚的PackageName一样</li>
<li>选择自有证书</li>
<li>证书别名可以通过上面的命令查看</li>
<li>证书密钥是刚刚申请时的密钥</li>
<li>文件用上面生成的证书文件</li>
</ol>
<p><img data-src="https://img.imgdb.cn/item/603e431e360785be54533d9a.png" alt="8"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>[1] <a href="https://developer.amap.com/faq/android/map-sdk/create-project/43112">如何获取SHA1</a></li>
<li>[2] <a href="https://ask.dcloud.net.cn/article/35777">Android平台签名证书(.keystore)生成指南</a></li>
<li>[3] [高德web服务API](</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>uniapp</category>
      </categories>
      <tags>
        <tag>uniapp</tag>
      </tags>
  </entry>
  <entry>
    <title>uni组件之——webview与APP之间的通讯</title>
    <url>/2021/03/01/uniapp/uni%E7%BB%84%E4%BB%B6%E4%B9%8B%E2%80%94%E2%80%94webview%E4%B8%8EAPP%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF/</url>
    <content><![CDATA[<h1 id="uni组件之——webview与APP之间的通讯"><a href="#uni组件之——webview与APP之间的通讯" class="headerlink" title="uni组件之——webview与APP之间的通讯"></a>uni组件之——webview与APP之间的通讯</h1><p>首先，让我们来谈谈应用的业务场景。大伙的业务场景是什么样我不知道，我来谈谈我踩坑时的业务场景。</p>
<p>老板：我们有个移动端的网页项目，但是为了唬客户，我们需要把这个网页打包成ios端和安卓端的app，页面中有一个需要调用摄像头的拍照签到功能。</p>
<p>我内心活动：ok，uni + webview没跑了，但是webview是不能直接调用手机的摄像头的，他的逻辑大概是，点击网页的签到按钮触发一个事件，事件给app发送一个我要使用手机摄像头的需求，然后再uni中收到了信号，去调起手机的摄像头。</p>
<p>所以，搞明白了业务场景，不管三七二十一，先上案例，看看最简单的demo咋实现。</p>
<span id="more"></span>
<hr>
<h2 id="html页面："><a href="#html页面：" class="headerlink" title="html页面："></a>html页面：</h2><p>首先模拟一个网页，我们就用一个静态的html网页就好。webview要访问本地静态页面的话，静态页面是需要放在static目录底下的，在这我们命名为index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>网页实时向APP发送消息<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- uni 的 SDK，必须引用。 --&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://js.cdn.aliyun.dcloud.net.cn/dev/uni-app/uni.webview.1.5.2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 微信 JS-SDK 如果不需要兼容小程序，则无需引用此 JS 文件。 --&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://res.wx.qq.com/open/js/jweixin-1.4.0.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 在引用依赖的文件后，需要在 HTML 中监听 UniAppJSBridgeReady 事件触发后，才能安全调用 uni 的 API。</span></span></span><br><span class="line"><span class="javascript">		<span class="built_in">document</span>.addEventListener(<span class="string">&#x27;UniAppJSBridgeReady&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">		    uni.getEnv(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;  </span></span><br><span class="line"><span class="javascript">		        <span class="built_in">console</span>.log(<span class="string">&#x27;当前环境：&#x27;</span> + <span class="built_in">JSON</span>.stringify(res));  </span></span><br><span class="line"><span class="javascript">		    &#125;);</span></span><br><span class="line"><span class="javascript">        	<span class="comment">//向APP发送消息</span></span></span><br><span class="line"><span class="javascript">        	uni.postMessage(&#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">action</span>: <span class="string">&#x27;message&#x27;</span></span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;);</span></span><br><span class="line"><span class="javascript">            <span class="comment">//接收APP发送过来的消息</span></span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">handleMessage</span>(<span class="params">evt</span>)</span> &#123;  </span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&#x27;接收到的消息：&#x27;</span> + <span class="built_in">JSON</span>.stringify(evt.detail.data));  </span></span><br><span class="line"><span class="javascript">            &#125;  </span></span><br><span class="line"><span class="javascript">		&#125;);</span></span><br><span class="line"><span class="javascript">	</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="uni页面："><a href="#uni页面：" class="headerlink" title="uni页面："></a>uni页面：</h2><p>这里为index.nvue页面(注意这个nvue，跟vue页面是有差别的，后面就是踩坑点之一)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;webview-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">web-view</span> <span class="attr">ref</span>=<span class="string">&quot;webview&quot;</span> <span class="attr">class</span>=<span class="string">&quot;webview&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../../static/index.html&quot;</span> @<span class="attr">onPostMessage</span>=<span class="string">&quot;handleMessage&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">web-view</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">				<span class="attr">camera</span>: <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">				<span class="attr">progress</span>: <span class="number">0</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">				<span class="attr">wv</span>: <span class="literal">null</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		&#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="function"><span class="title">onLoad</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="keyword">const</span> self = <span class="built_in">this</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="comment">// #ifdef APP-PLUS  </span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="keyword">let</span> currentWebview = getCurrentPages()[<span class="number">0</span>];</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">				self.wv = currentWebview.$getAppWebview();</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                 <span class="comment">//调用下面函数</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">             	 <span class="built_in">this</span>.handlePostMessage(<span class="string">&quot;消息&quot;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			&#125;, <span class="number">1000</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="comment">// #endif</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">		&#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">         <span class="function"><span class="title">mouted</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">         &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="comment">// 接收h5页面发来的键值判断需要执行的操作</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="function"><span class="title">handleMessage</span>(<span class="params">evt</span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">				<span class="built_in">console</span>.log(<span class="string">&quot;postMessage: &quot;</span>, evt)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			&#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="comment">// 获取到对应webview(关键)通过evalJs(注意大小写，如果不知道evalJ是什么，可自行百度) 执行网页的函数，可对其进行传参，完成与网页的通讯</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="function"><span class="title">handlePostMessage</span>(<span class="params">res</span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="built_in">this</span>.$refs.webview.evalJs(<span class="string">`handleMessage(<span class="subst">$&#123;res&#125;</span>)`</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span></span><br><span class="line"><span class="css"><span class="xml">	<span class="selector-class">.webview-box</span> &#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">		<span class="attribute">position</span>: absolute;</span></span></span><br><span class="line"><span class="css"><span class="xml">		<span class="attribute">left</span>: <span class="number">0px</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">		<span class="attribute">right</span>: <span class="number">0px</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">		<span class="attribute">top</span>: <span class="number">0px</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">		<span class="attribute">bottom</span>: <span class="number">0px</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">	&#125;</span></span></span><br><span class="line"><span class="css"><span class="xml"></span></span></span><br><span class="line"><span class="css"><span class="xml">	<span class="selector-class">.webview</span> &#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">		<span class="attribute">flex</span>: <span class="number">1</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">	&#125;</span></span></span><br><span class="line"><span class="css"><span class="xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        好了，是不是觉得很简单，事实上也很简单，但是鄙人非出脑瘫，踩了两个巨坑。两个都是在uni的页面的，如果大伙也踩到的话，那恭喜了，看到了我。</p>
<p>​        第一，我用的是nvue页面，nvue获取webview窗口的方式是与普通vue获取webview的方式不一样的，这一步非常关键，如果获取不正确就算你以下写的东西是正确的也没有效果，具体是什么原理我也没深究，以后懂了再更好了，先实现业务。具体获取方法看案例，自己console一下看看要获取的是哪个webview，因为如果大伙的项目是有自定义导航栏获取其他nuve组件的话也算是一个webview。</p>
<p>​        第二个坑就是，一定要用在uni的webview组件上使用<code>@onPostMessage</code>这个方法进行消息的监听，我当时也不知道犯了什么病，我用的是message，老半天调不出。message只有在特定的情况下才会接收到网页的消息，比如你执行了返回或着其他的特定场景操作的时候，具体可以看官网给出的。踩坑记录就到这啦，希望能帮助到大伙。</p>
<ul>
<li>参考资料：[1] <a href="https://ask.dcloud.net.cn/article/35083">dcloud社区</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>uniapp</category>
      </categories>
      <tags>
        <tag>uniapp</tag>
        <tag>webview</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题-19.04.25</title>
    <url>/2019/04/25/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-19-04-25/</url>
    <content><![CDATA[<p>My Metamorphosis<br>a打印出什么？为什么？</p>
<span id="more"></span>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	var = 1;</span><br><span class="line">	if(function b()&#123;&#125;)&#123;</span><br><span class="line">		a += typeof(b)</span><br><span class="line">	&#125;</span><br><span class="line">	console.log(a);</span><br><span class="line">&lt;/script&gt;	</span><br></pre></td></tr></table></figure>
<hr>
<p>结果：<br>1undefined</p>
<p>因为if(function b(){})当中，括号中的function b(){}会被隐式转换成ture，会把function b(){}变成表达式，失去对函数的索引，无法变量提升。所以if(true)之后执行{}中的内容，b会报错is not defined。</p>
<p>由于typeof()在es5中返回字符串且不会报错，所以typeof(b) = undefined，最后a = a + undefined，故a打印出1undefined。</p>
<hr>
<p>参考文献：Duing</p>
]]></content>
      <categories>
        <category>每天一题</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>每天进步一点点</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题-19.04.27</title>
    <url>/2019/04/27/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-19-04-27/</url>
    <content><![CDATA[<p>My Metamorphosis<br>函数形参与arguments的关系，以下代码运行结果是什么？</p>
<span id="more"></span>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    function course(name, age) &#123;</span><br><span class="line">        console.log(age);</span><br><span class="line">        console.log(arguments[1]);</span><br><span class="line">        arguments[1] = 2;</span><br><span class="line">        console.log(age);</span><br><span class="line">        console.log(arguments[1]);</span><br><span class="line">    &#125;</span><br><span class="line">    course(&#x27;渡一教育&#x27;);</span><br><span class="line">&lt;script&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p>结果：<br>‘undefined’<br>‘undefined’<br>‘undefined’<br>2</p>
<hr>
<p>形参的空间与arguments对象内存空间并不重叠。</p>
<p>如果形参和arguments都存在，则这两者值是同步的；</p>
<p>如果形参和arguments当中，有其中之一无值，则此值不会得以同步。</p>
<hr>
<p>参考文献：Duing</p>
]]></content>
      <categories>
        <category>每天一题</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>每天进步一点点</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题-19.04.26</title>
    <url>/2019/04/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-19-04-26/</url>
    <content><![CDATA[<p>My Metamorphosis<br>考虑下面的两个函数，它们都会返回同样的值吗？为什么或者为什么不？</p>
<span id="more"></span>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	function foo1()&#123;</span><br><span class="line">		return&#123;</span><br><span class="line">			bar: &quot;hello&quot;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	function foo2()&#123;</span><br><span class="line">		return</span><br><span class="line">		&#123;</span><br><span class="line">			bar: &quot;hello&quot;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p>结果：<br>foo1 returns:<br>Object {bar: “hello”}<br>foo2 returns:<br>undefined</p>
<hr>
<p>foo2()返回未定义而没有引发任何错误。<br>原因与JavaScript中分号在技术上是可选的事实有关（不能忽略它们）。因此，在foo2()中遇到包含return语句的行（没有其它内容）时，会在return语句之后立即自动插入分号。<br>由于代码的其余部分是完全有效的，即使它没有被调用或做任何事情（它只是一个未使用的代码块，它定义了一个属性栏，它等于字符串”hello”），所以不会抛出任何错误。<br>这种行为也被认为遵循了在JavaScript中奖一行开头大括号放在行尾的约定，而不是在新行的开头。</p>
<hr>
<p>参考文献：Duing</p>
]]></content>
      <categories>
        <category>每天一题</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>每天进步一点点</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题-19.04.28</title>
    <url>/2019/04/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-19-04-28/</url>
    <content><![CDATA[<p>My Metamorphosis<br>break和continue的区别</p>
<span id="more"></span>
<hr>
<p>1、break语句可以用于循环语句，也可以用于分支语句（switch），而continue语句只能用于循环语句；<br>2、break语句用于跳出全部循环，而continue用于结束本次循环。</p>
<hr>
<p>参考文献：Duing</p>
]]></content>
      <categories>
        <category>每天一题</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>每天进步一点点</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack</title>
    <url>/2021/10/18/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack/</url>
    <content><![CDATA[<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><span id="more"></span>
<hr>
<h1 id="一、-什么是webpack"><a href="#一、-什么是webpack" class="headerlink" title="一、 什么是webpack?"></a>一、 什么是webpack?</h1><p>​        webpack俗称打包工具，本质上，<strong>webpack</strong> 是一个资源打包器，将你项目中所需的每一个模块打包成一个或多个压缩过的文件，也可以理解为webpack是一个代码的搬运工，其实浏览器压根就认识不了我们日常所写的.vue、.ts、.scss、.less等文件，我们之所以那样写，是为了将某个组件抽离出来，以便于更好的开发维护。然而我们是好维护了，但是浏览器不认识了，于是我们通过webpack里的各种loader编译插件去进行一个代码的转换，转换成能让浏览器认识的文件。</p>
<p>​        其实像这样的工具还有很多，只是webpack当下较为流行，然而他也有打包慢、ES模块除Module外全用babel转换，但是一部分ES2015 语法的 firefox 与 chrome 浏览器中能直接跑的代码，无法用 webpack 编译等缺点。最近尤大开源了一个新的打包工具vite也十分火热，建议学习。</p>
<h1 id="二、-安装"><a href="#二、-安装" class="headerlink" title="二、 安装"></a>二、 安装</h1><p>开发环境：<code>--save-dev</code> -&gt;<code>-D</code></p>
<p>生产（线上）环境：<code>--save</code> -&gt;  -&gt; <code>-S</code></p>
<p><code>npm i -D webpack webpack-cli webpack-dev-server babel-loader@7 babel-core babel-preset-env babel-plugin-transform-runtime babel-plugin-transform-decorators babel-plugin-transform-decorators-legacy sass-loader node-sass css-loader style-loader ejs-loader html-webpack-plugin --registry=https://registry.npm.taobao.org</code></p>
<h1 id="三-webpack三件套"><a href="#三-webpack三件套" class="headerlink" title="三. webpack三件套"></a>三. webpack三件套</h1><ul>
<li>webpck</li>
<li>webpck-cli</li>
<li>webpack-dev-server（实时的编译）</li>
</ul>
<h1 id="四-常用的loader"><a href="#四-常用的loader" class="headerlink" title="四. 常用的loader"></a>四. 常用的loader</h1><h2 id="1-处理js"><a href="#1-处理js" class="headerlink" title="1. 处理js"></a>1. 处理js</h2><ul>
<li>babel、babel-loader、@babel/core、@babel/preset-env、babel-plugin-transform-runtime（将新的es6以上的语法编译成es6之前的语法，便于兼容老的浏览器）</li>
<li>babel-plugin-transform-decorators、babel-plugin-transform-decorators-legacy（装饰器）</li>
<li>ts-loader（将.ts文件转换为浏览器所认识的js代码）</li>
</ul>
<h2 id="2-处理样式"><a href="#2-处理样式" class="headerlink" title="2. 处理样式"></a>2. 处理样式</h2><ul>
<li>sass、sass-loader、node-sass（将.sass/scss文件转换为浏览器所认识的css代码）</li>
<li>css-loader（处理 <code>import</code> / <code>require</code>（） <code>@import</code> / <code>url</code> 引入的内容）</li>
<li>style-loader（将css-loader解析后的内容挂载到html页面当中，style-loader是不能单独使用的，应为它并不负责解析 css 之前的依赖关系，每个loader的功能都是单一的，各自拆分独立）</li>
<li>postcss-loader、autoprefixer（自动加上不同浏览器内核样式的前缀）</li>
</ul>
<h2 id="3-处理模版"><a href="#3-处理模版" class="headerlink" title="3. 处理模版"></a>3. 处理模版</h2><ul>
<li>ejs-loader</li>
<li>html-webpack-plugin（处理html）</li>
</ul>
<h2 id="4-Vue"><a href="#4-Vue" class="headerlink" title="4. Vue"></a>4. Vue</h2><ul>
<li>vue-loader（将.vue文件转换为浏览器所认识的js代码）</li>
<li>VueComponentsPlugin</li>
</ul>
<h1 id="五、path路径管理包"><a href="#五、path路径管理包" class="headerlink" title="五、path路径管理包"></a>五、path路径管理包</h1><p>node路径管理的包</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>) <span class="comment">// 引入路径管理的包</span></span><br></pre></td></tr></table></figure>

<h2 id="1-resolve"><a href="#1-resolve" class="headerlink" title="1. resolve"></a>1. resolve</h2><h2 id="2-join"><a href="#2-join" class="headerlink" title="2. join"></a>2. join</h2><h1 id="六、-使用方法"><a href="#六、-使用方法" class="headerlink" title="六、 使用方法"></a>六、 使用方法</h1><p>在项目的根目录新建一个<code>webpack.config.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>) <span class="comment">// 引入路径管理的包</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	<span class="attr">mode</span>: <span class="string">&#x27;devalopment&#x27;</span>, <span class="comment">// 所处模式：(devalopment/production)开发/生产</span></span><br><span class="line">	<span class="attr">entry</span>: path.join(__dirname, <span class="string">&#x27;src&#x27;</span>, <span class="string">&#x27;index.js&#x27;</span>), <span class="comment">// 从某个文件开始打包</span></span><br><span class="line">	<span class="attr">output</span>: &#123; <span class="comment">// 指定打包的路径和文件名</span></span><br><span class="line">		<span class="attr">path</span>: path.join(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">		<span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">module</span>: &#123;</span><br><span class="line">		<span class="attr">rules</span>: [</span><br><span class="line">			&#123;<span class="attr">test</span>: <span class="regexp">/\.vue$/</span>, use: <span class="string">&#x27;vue-loader&#x27;</span>&#125;,</span><br><span class="line">			&#123;<span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>, use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;scss-loader&#x27;</span>]&#125;,</span><br><span class="line">			&#123;<span class="attr">test</span>: <span class="regexp">/\.css$/</span>, use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]&#125;,</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">test</span>: <span class="regexp">/\.m?js$/</span>,</span><br><span class="line">				exclude: <span class="regexp">/node_modules/</span>, <span class="comment">// 排除node_modules目录，不用编译这个文件夹里面的东西</span></span><br><span class="line">				use: &#123;</span><br><span class="line">					<span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">					<span class="attr">options</span>: &#123;</span><br><span class="line">						<span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>] <span class="comment">// babel预设</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">plugins</span>: [</span><br><span class="line"></span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>工程化</category>
      </categories>
      <tags>
        <tag>工程化</tag>
        <tag>分享</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题-19.04.29</title>
    <url>/2019/04/29/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-19-04-29/</url>
    <content><![CDATA[<p>My Metamorphosis<br>下面的代码运行结果是什么？</p>
<span id="more"></span>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var x = 1;</span><br><span class="line">    var y = 2;</span><br><span class="line">    function show() &#123;</span><br><span class="line">        var x = 3;</span><br><span class="line">        return &#123;</span><br><span class="line">            x: x,</span><br><span class="line">            fun: function(a,b) &#123;</span><br><span class="line">                x = a + b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var obj = show();</span><br><span class="line">    obj.fun(x,y);</span><br><span class="line">    console.log(obj.x);</span><br><span class="line">    console.log(x);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p>结果：<br>3 1</p>
<p>分析：<br>1、obj所得的是show函数的返回值，即return返回的对象，在调用obj的fun之后，obj这个对象的x被赋值为3；<br>2、最后一句console.log代码，输出的x是在全局作用域当中的x，因此返回的值应该是全局变量x（数字1）。</p>
<hr>
<p>参考文献：Duing</p>
]]></content>
      <categories>
        <category>每天一题</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>每天进步一点点</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex</title>
    <url>/2021/11/09/vue/vuex/</url>
    <content><![CDATA[<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><span id="more"></span>
<hr>
<h1 id="一、开始"><a href="#一、开始" class="headerlink" title="一、开始"></a>一、开始</h1><p>每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的**状态 (state)**。Vuex 和单纯的全局对象有以下两点不同：</p>
<ol>
<li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地<strong>提交 (commit) mutation</strong>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li>
</ol>
<h2 id="1-创建store"><a href="#1-创建store" class="headerlink" title="1. 创建store"></a>1. 创建store</h2><p>提供一个初始 state 对象和一些 mutation：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可以通过 <code>store.state</code> 来获取状态对象，以及通过 <code>store.commit</code> 方法触发状态变更：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(store.state.count) <span class="comment">// -&gt; 1</span></span><br></pre></td></tr></table></figure>

<h2 id="2-注入store"><a href="#2-注入store" class="headerlink" title="2. 注入store"></a>2. 注入store</h2><p>为了在 Vue 组件中访问 <code>this.$store</code> property，你需要为 Vue 实例提供创建好的 store。Vuex 提供了一个从根组件向所有子组件，以 <code>store</code> 选项的方式“注入”该 store 的机制：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">store</span>: store,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="二、核心概念"><a href="#二、核心概念" class="headerlink" title="二、核心概念"></a>二、核心概念</h1><h2 id="1-State"><a href="#1-State" class="headerlink" title="1. State"></a>1. State</h2><p>相当于vue里的date</p>
<h3 id="mapState"><a href="#mapState" class="headerlink" title="mapState"></a>mapState</h3><p>当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 <code>mapState</code> 辅助函数帮助我们生成计算属性，让你少按几次键</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在单独构建的版本中辅助函数为 Vuex.mapState</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">computed</span>: mapState(&#123;</span><br><span class="line">    <span class="comment">// 箭头函数可使代码更简练</span></span><br><span class="line">    <span class="attr">count</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传字符串参数 &#x27;count&#x27; 等同于 `state =&gt; state.count`</span></span><br><span class="line">    <span class="attr">countAlias</span>: <span class="string">&#x27;count&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span></span><br><span class="line">    countPlusLocalState (state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + <span class="built_in">this</span>.localCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 <code>mapState</code> 传一个字符串数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  <span class="comment">// 映射 this.count 为 store.state.count</span></span><br><span class="line">  <span class="string">&#x27;count&#x27;</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<h3 id="对象展开运算符"><a href="#对象展开运算符" class="headerlink" title="对象展开运算符"></a>对象展开运算符</h3><p><code>mapState</code> 函数返回的是一个对象。我们如何将它与局部计算属性混合使用呢？通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 <code>computed</code> 属性。但是自从有了<a href="https://github.com/tc39/proposal-object-rest-spread">对象展开运算符 (opens new window)</a>，我们可以极大地简化写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  localComputed () &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将此对象混入到外部对象中</span></span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Getters"><a href="#2-Getters" class="headerlink" title="2. Getters"></a>2. Getters</h2><p>相当于vue里面的computed</p>
<h3 id="mapGetters"><a href="#mapGetters" class="headerlink" title="mapGetters"></a>mapGetters</h3><p><code>mapGetters</code> 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span></span><br><span class="line">    ...mapGetters([</span><br><span class="line">      <span class="string">&#x27;doneTodosCount&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;anotherGetter&#x27;</span>,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你想将一个 getter 属性另取一个名字，使用对象形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...mapGetters(&#123;</span><br><span class="line">  <span class="comment">// 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`</span></span><br><span class="line">  <span class="attr">doneCount</span>: <span class="string">&#x27;doneTodosCount&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="3-Mutation"><a href="#3-Mutation" class="headerlink" title="3. Mutation"></a>3. Mutation</h2><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 **回调函数 (handler)**。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      <span class="comment">// 变更状态</span></span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 <code>increment</code> 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 <strong>store.commit</strong> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.commit(<span class="string">&#x27;increment&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="提交载荷（Payload）"><a href="#提交载荷（Payload）" class="headerlink" title="提交载荷（Payload）"></a>提交载荷（Payload）</h3><p>你可以向 <code>store.commit</code> 传入额外的参数，即 mutation 的 <strong>载荷（payload）</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="attr">mutations</span>: &#123;</span><br><span class="line">  increment (state, n) &#123;</span><br><span class="line">    state.count += n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.commit(<span class="string">&#x27;increment&#x27;</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="attr">mutations</span>: &#123;</span><br><span class="line">  increment (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.commit(<span class="string">&#x27;increment&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">amount</span>: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="对象风格的提交方式"><a href="#对象风格的提交方式" class="headerlink" title="对象风格的提交方式"></a>对象风格的提交方式</h3><p>提交 mutation 的另一种方式是直接使用包含 <code>type</code> 属性的对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.commit(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;increment&#x27;</span>,</span><br><span class="line">  <span class="attr">amount</span>: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Mutation-需遵守-Vue-的响应规则"><a href="#Mutation-需遵守-Vue-的响应规则" class="headerlink" title="Mutation 需遵守 Vue 的响应规则"></a>Mutation 需遵守 Vue 的响应规则</h3><p>既然 Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：</p>
<ol>
<li>最好提前在你的 store 中初始化好所有所需属性。</li>
<li>当需要在对象上添加新属性时，你应该</li>
</ol>
<ul>
<li><p>使用 <code>Vue.set(obj, &#39;newProp&#39;, 123)</code>, 或者</p>
</li>
<li><p>以新对象替换老对象。例如，利用<a href="https://github.com/tc39/proposal-object-rest-spread">对象展开运算符 (opens new window)</a>我们可以这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">state.obj = &#123; ...state.obj, <span class="attr">newProp</span>: <span class="number">123</span> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用常量替代-Mutation-事件类型"><a href="#使用常量替代-Mutation-事件类型" class="headerlink" title="使用常量替代 Mutation 事件类型"></a>使用常量替代 Mutation 事件类型</h3><p>使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mutation-types.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SOME_MUTATION = <span class="string">&#x27;SOME_MUTATION&#x27;</span></span><br><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; SOME_MUTATION &#125; <span class="keyword">from</span> <span class="string">&#x27;./mutation-types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="comment">// 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span></span><br><span class="line">    [SOME_MUTATION] (state) &#123;</span><br><span class="line">      <span class="comment">// mutate state</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>用不用常量取决于你——在需要多人协作的大型项目中，这会很有帮助。但如果你不喜欢，你完全可以不这样做。</p>
<h3 id="Mutation-必须是同步函数"><a href="#Mutation-必须是同步函数" class="headerlink" title="Mutation 必须是同步函数"></a>Mutation 必须是同步函数</h3><p>一条重要的原则就是要记住 <strong>mutation 必须是同步函数</strong>。为什么？请参考下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  someMutation (state) &#123;</span><br><span class="line">    api.callAsyncMethod(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。</p>
<h3 id="mapMutations"><a href="#mapMutations" class="headerlink" title="mapMutations"></a>mapMutations</h3><p>你可以在组件中使用 <code>this.$store.commit(&#39;xxx&#39;)</code> 提交 mutation，或者使用 <code>mapMutations</code> 辅助函数将组件中的 methods 映射为 <code>store.commit</code> 调用（需要在根节点注入 <code>store</code>）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    ...mapMutations([</span><br><span class="line">      <span class="string">&#x27;increment&#x27;</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.commit(&#x27;increment&#x27;)`</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// `mapMutations` 也支持载荷：</span></span><br><span class="line">      <span class="string">&#x27;incrementBy&#x27;</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&#x27;incrementBy&#x27;, amount)`</span></span><br><span class="line">    ]),</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      <span class="attr">add</span>: <span class="string">&#x27;increment&#x27;</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.commit(&#x27;increment&#x27;)`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Actions"><a href="#4-Actions" class="headerlink" title="4. Actions"></a>4. Actions</h2><p>Action 类似于 mutation，不同在于：</p>
<ul>
<li>Action 提交的是 mutation，而不是直接变更状态。</li>
<li>Action 可以包含任意异步操作。</li>
</ul>
<p>让我们来注册一个简单的 action：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 <code>context.commit</code> 提交一个 mutation，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters。当我们在之后介绍到 <a href="https://vuex.vuejs.org/zh/guide/modules.html">Modules</a> 时，你就知道 context 对象为什么不是 store 实例本身了。</p>
<p>实践中，我们会经常用到 ES2015 的 <a href="https://github.com/lukehoban/es6features#destructuring">参数解构 (opens new window)</a>来简化代码（特别是我们需要调用 <code>commit</code> 很多次的时候）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  increment (&#123; commit &#125;) &#123;</span><br><span class="line">    commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分发-Action"><a href="#分发-Action" class="headerlink" title="分发 Action"></a>分发 Action</h3><p>Action 通过 <code>store.dispatch</code> 方法触发：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.dispatch(<span class="string">&#x27;increment&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 <strong>mutation 必须同步执行</strong>这个限制么？Action 就不受约束！我们可以在 action 内部执行<strong>异步</strong>操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  incrementAsync (&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Actions 支持同样的载荷方式和对象方式进行分发：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以载荷形式分发</span></span><br><span class="line">store.dispatch(<span class="string">&#x27;incrementAsync&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">amount</span>: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以对象形式分发</span></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;incrementAsync&#x27;</span>,</span><br><span class="line">  <span class="attr">amount</span>: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>来看一个更加实际的购物车示例，涉及到<strong>调用异步 API</strong> 和<strong>分发多重 mutation</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  checkout (&#123; commit, state &#125;, products) &#123;</span><br><span class="line">    <span class="comment">// 把当前购物车的物品备份起来</span></span><br><span class="line">    <span class="keyword">const</span> savedCartItems = [...state.cart.added]</span><br><span class="line">    <span class="comment">// 发出结账请求，然后乐观地清空购物车</span></span><br><span class="line">    commit(types.CHECKOUT_REQUEST)</span><br><span class="line">    <span class="comment">// 购物 API 接受一个成功回调和一个失败回调</span></span><br><span class="line">    shop.buyProducts(</span><br><span class="line">      products,</span><br><span class="line">      <span class="comment">// 成功操作</span></span><br><span class="line">      <span class="function">() =&gt;</span> commit(types.CHECKOUT_SUCCESS),</span><br><span class="line">      <span class="comment">// 失败操作</span></span><br><span class="line">      <span class="function">() =&gt;</span> commit(types.CHECKOUT_FAILURE, savedCartItems)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意我们正在进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）。</p>
<h3 id="mapActions"><a href="#mapActions" class="headerlink" title="mapActions"></a>mapActions</h3><p>你在组件中使用 <code>this.$store.dispatch(&#39;xxx&#39;)</code> 分发 action，或者使用 <code>mapActions</code> 辅助函数将组件的 methods 映射为 <code>store.dispatch</code> 调用（需要先在根节点注入 <code>store</code>）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    ...mapActions([</span><br><span class="line">      <span class="string">&#x27;increment&#x27;</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.dispatch(&#x27;increment&#x27;)`</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// `mapActions` 也支持载荷：</span></span><br><span class="line">      <span class="string">&#x27;incrementBy&#x27;</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&#x27;incrementBy&#x27;, amount)`</span></span><br><span class="line">    ]),</span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line">      <span class="attr">add</span>: <span class="string">&#x27;increment&#x27;</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.dispatch(&#x27;increment&#x27;)`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组合-Action"><a href="#组合-Action" class="headerlink" title="组合 Action"></a>组合 Action</h3><p>Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？</p>
<p>首先，你需要明白 <code>store.dispatch</code> 可以处理被触发的 action 的处理函数返回的 Promise，并且 <code>store.dispatch</code> 仍旧返回 Promise：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">&#x27;someMutation&#x27;</span>)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在你可以：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.dispatch(<span class="string">&#x27;actionA&#x27;</span>).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在另外一个 action 中也可以：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="string">&#x27;actionA&#x27;</span>).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">&#x27;someOtherMutation&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，如果我们利用 <a href="https://tc39.github.io/ecmascript-asyncawait/">async / await (opens new window)</a>，我们可以如下组合 action：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设 getData() 和 getOtherData() 返回的是 Promise</span></span><br><span class="line"></span><br><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">  <span class="keyword">async</span> actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    commit(<span class="string">&#x27;gotData&#x27;</span>, <span class="keyword">await</span> getData())</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">await</span> dispatch(<span class="string">&#x27;actionA&#x27;</span>) <span class="comment">// 等待 actionA 完成</span></span><br><span class="line">    commit(<span class="string">&#x27;gotOtherData&#x27;</span>, <span class="keyword">await</span> getOtherData())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个 <code>store.dispatch</code> 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p>
</blockquote>
<h2 id="5-Module"><a href="#5-Module" class="headerlink" title="5. Module"></a>5. Module</h2><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p>
<p>为了解决以上问题，Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: moduleA,</span><br><span class="line">    <span class="attr">b</span>: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure>

<h3 id="模块的局部状态"><a href="#模块的局部状态" class="headerlink" title="模块的局部状态"></a>模块的局部状态</h3><p>对于模块内部的 mutation 和 getter，接收的第一个参数是<strong>模块的局部状态对象</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      <span class="comment">// 这里的 `state` 对象是模块的局部状态</span></span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    doubleCount (state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，对于模块内部的 action，局部状态通过 <code>context.state</code> 暴露出来，根节点状态则为 <code>context.rootState</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((state.count + rootState.count) % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    sumWithRootCount (state, getters, rootState) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + rootState.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>默认情况下，模块内部的 action、mutation 和 getter 是注册在<strong>全局命名空间</strong>的——这样使得多个模块能够对同一 mutation 或 action 作出响应。</p>
<p>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 <code>namespaced: true</code> 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    <span class="attr">account</span>: &#123;</span><br><span class="line">      <span class="attr">namespaced</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 模块内容（module assets）</span></span><br><span class="line">      <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123; ... &#125;), <span class="comment">// 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响</span></span><br><span class="line">      <span class="attr">getters</span>: &#123;</span><br><span class="line">        isAdmin () &#123; ... &#125; <span class="comment">// -&gt; getters[&#x27;account/isAdmin&#x27;]</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">actions</span>: &#123;</span><br><span class="line">        login () &#123; ... &#125; <span class="comment">// -&gt; dispatch(&#x27;account/login&#x27;)</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">mutations</span>: &#123;</span><br><span class="line">        login () &#123; ... &#125; <span class="comment">// -&gt; commit(&#x27;account/login&#x27;)</span></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 嵌套模块</span></span><br><span class="line">      <span class="attr">modules</span>: &#123;</span><br><span class="line">        <span class="comment">// 继承父模块的命名空间</span></span><br><span class="line">        <span class="attr">myPage</span>: &#123;</span><br><span class="line">          <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">          <span class="attr">getters</span>: &#123;</span><br><span class="line">            profile () &#123; ... &#125; <span class="comment">// -&gt; getters[&#x27;account/profile&#x27;]</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进一步嵌套命名空间</span></span><br><span class="line">        <span class="attr">posts</span>: &#123;</span><br><span class="line">          <span class="attr">namespaced</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">          <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">          <span class="attr">getters</span>: &#123;</span><br><span class="line">            popular () &#123; ... &#125; <span class="comment">// -&gt; getters[&#x27;account/posts/popular&#x27;]</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>启用了命名空间的 getter 和 action 会收到局部化的 <code>getter</code>，<code>dispatch</code> 和 <code>commit</code>。换言之，你在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 <code>namespaced</code> 属性后不需要修改模块内的代码。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
        <category>Vuex</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vex</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue深入了解组件-易遗漏点</title>
    <url>/2021/05/20/vue/2.%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="Vue深入了解组件-易遗漏点"><a href="#Vue深入了解组件-易遗漏点" class="headerlink" title="Vue深入了解组件-易遗漏点"></a>Vue深入了解组件-易遗漏点</h1><span id="more"></span>
<hr>
<h1 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h1><h2 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h2><hr>
<h3 id="基础组件的自动化全局注册"><a href="#基础组件的自动化全局注册" class="headerlink" title="基础组件的自动化全局注册"></a>基础组件的自动化全局注册</h3><p>可能你的许多组件只是包裹了一个输入框或按钮之类的元素，是相对通用的。我们有时候会把它们称为基础组件，它们会在各个组件中被频繁的用到。</p>
<p>所以会导致很多组件里都会有一个包含基础组件的长列表：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> BaseButton <span class="keyword">from</span> <span class="string">&#x27;./BaseButton.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> BaseIcon <span class="keyword">from</span> <span class="string">&#x27;./BaseIcon.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> BaseInput <span class="keyword">from</span> <span class="string">&#x27;./BaseInput.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    BaseButton,</span><br><span class="line">    BaseIcon,</span><br><span class="line">    BaseInput</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而只是用于模板中的一小部分：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">BaseInput</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">&quot;searchText&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">keydown.enter</span>=<span class="string">&quot;search&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BaseButton</span> @<span class="attr">click</span>=<span class="string">&quot;search&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">BaseIcon</span> <span class="attr">name</span>=<span class="string">&quot;search&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">BaseButton</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你恰好使用了 webpack (或在内部使用了 webpack 的 Vue CLI 3+)，那么就可以使用 <code>require.context</code> 只全局注册这些非常通用的基础组件。这里有一份可以让你在应用入口文件 (比如 <code>src/main.js</code>) 中全局导入基础组件的示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> upperFirst <span class="keyword">from</span> <span class="string">&#x27;lodash/upperFirst&#x27;</span></span><br><span class="line"><span class="keyword">import</span> camelCase <span class="keyword">from</span> <span class="string">&#x27;lodash/camelCase&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> requireComponent = <span class="built_in">require</span>.context(</span><br><span class="line">  <span class="comment">// 其组件目录的相对路径</span></span><br><span class="line">  <span class="string">&#x27;./components&#x27;</span>,</span><br><span class="line">  <span class="comment">// 是否查询其子目录</span></span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 匹配基础组件文件名的正则表达式</span></span><br><span class="line">  <span class="regexp">/Base[A-Z]\w+\.(vue|js)$/</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">requireComponent.keys().forEach(<span class="function"><span class="params">fileName</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 获取组件配置</span></span><br><span class="line">  <span class="keyword">const</span> componentConfig = requireComponent(fileName)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取组件的 PascalCase 命名</span></span><br><span class="line">  <span class="keyword">const</span> componentName = upperFirst(</span><br><span class="line">    camelCase(</span><br><span class="line">      <span class="comment">// 获取和目录深度无关的文件名</span></span><br><span class="line">      fileName</span><br><span class="line">        .split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        .pop()</span><br><span class="line">        .replace(<span class="regexp">/\.\w+$/</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全局注册组件</span></span><br><span class="line">  Vue.component(</span><br><span class="line">    componentName,</span><br><span class="line">    <span class="comment">// 如果这个组件选项是通过 `export default` 导出的，</span></span><br><span class="line">    <span class="comment">// 那么就会优先使用 `.default`，</span></span><br><span class="line">    <span class="comment">// 否则回退到使用模块的根。</span></span><br><span class="line">    componentConfig.default || componentConfig</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>记住<strong>全局注册的行为必须在根 Vue 实例 (通过 <code>new Vue</code>) 创建之前发生</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Globally register all base components for convenience, because they</span></span><br><span class="line"><span class="comment">// will be used very frequently. Components are registered using the</span></span><br><span class="line"><span class="comment">// PascalCased version of their file name.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://webpack.js.org/guides/dependency-management/#require-context</span></span><br><span class="line"><span class="keyword">const</span> requireComponent = <span class="built_in">require</span>.context(</span><br><span class="line">  <span class="comment">// Look for files in the current directory</span></span><br><span class="line">  <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">  <span class="comment">// Do not look in subdirectories</span></span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// Only include &quot;_base-&quot; prefixed .vue files</span></span><br><span class="line">  <span class="regexp">/_base-[\w-]+\.vue$/</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// For each matching file name...</span></span><br><span class="line">requireComponent.keys().forEach(<span class="function">(<span class="params">fileName</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Get the component config</span></span><br><span class="line">  <span class="keyword">const</span> componentConfig = requireComponent(fileName)</span><br><span class="line">  <span class="comment">// Get the PascalCase version of the component name</span></span><br><span class="line">  <span class="keyword">const</span> componentName = fileName</span><br><span class="line">    <span class="comment">// Remove the &quot;./_&quot; from the beginning</span></span><br><span class="line">    .replace(<span class="regexp">/^\.\/_/</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="comment">// Remove the file extension from the end</span></span><br><span class="line">    .replace(<span class="regexp">/\.\w+$/</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="comment">// Split up kebabs</span></span><br><span class="line">    .split(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">    <span class="comment">// Upper case</span></span><br><span class="line">    .map(<span class="function">(<span class="params">kebab</span>) =&gt;</span> kebab.charAt(<span class="number">0</span>).toUpperCase() + kebab.slice(<span class="number">1</span>))</span><br><span class="line">    <span class="comment">// Concatenated</span></span><br><span class="line">    .join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Globally register the component</span></span><br><span class="line">  Vue.component(componentName, componentConfig.default || componentConfig)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h1><h2 id="Prop-类型"><a href="#Prop-类型" class="headerlink" title="Prop 类型"></a>Prop 类型</h2><hr>
<p>到这里，我们只看到了以字符串数组形式列出的 prop：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;likes&#x27;</span>, <span class="string">&#x27;isPublished&#x27;</span>, <span class="string">&#x27;commentIds&#x27;</span>, <span class="string">&#x27;author&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>但是，通常你希望每个 prop 都有指定的值类型。这时，你可以以对象形式列出 prop，这些 property 的名称和值分别是 prop 各自的名称和类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">String</span>,</span><br><span class="line">  <span class="attr">likes</span>: <span class="built_in">Number</span>,</span><br><span class="line">  <span class="attr">isPublished</span>: <span class="built_in">Boolean</span>,</span><br><span class="line">  <span class="attr">commentIds</span>: <span class="built_in">Array</span>,</span><br><span class="line">  <span class="attr">author</span>: <span class="built_in">Object</span>,</span><br><span class="line">  <span class="attr">callback</span>: <span class="built_in">Function</span>,</span><br><span class="line">  <span class="attr">contactsPromise</span>: <span class="built_in">Promise</span> <span class="comment">// or any other constructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这不仅为你的组件提供了文档，还会在它们遇到错误的类型时从浏览器的 JavaScript 控制台提示用户。你会在这个页面接下来的部分看到类型检查和其它 prop 验证。</p>
<h2 id="传递静态或动态-Prop"><a href="#传递静态或动态-Prop" class="headerlink" title="传递静态或动态 Prop"></a>传递静态或动态 Prop</h2><hr>
<h3 id="传入一个对象的所有-property"><a href="#传入一个对象的所有-property" class="headerlink" title="传入一个对象的所有 property"></a>传入一个对象的所有 property</h3><p>如果你想要将一个对象的所有 property 都作为 prop 传入，你可以使用不带参数的 <code>v-bind</code> (取代 <code>v-bind:prop-name</code>)。例如，对于一个给定的对象 <code>post</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">post: &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;My Journey with Vue&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的模板：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind</span>=<span class="string">&quot;post&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:id</span>=<span class="string">&quot;post.id&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:title</span>=<span class="string">&quot;post.title&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h2><hr>
<p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。</p>
<p>额外的，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你<strong>不</strong>应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</p>
<p>这里有两种常见的试图变更一个 prop 的情形：</p>
<ol>
<li><p><strong>这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。</strong>在这种情况下，最好定义一个本地的 data property 并将这个 prop 用作其初始值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">&#x27;initialCounter&#x27;</span>],</span><br><span class="line"><span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">counter</span>: <span class="built_in">this</span>.initialCounter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>这个 prop 以一种原始的值传入且需要进行转换。</strong>在这种情况下，最好使用这个 prop 的值来定义一个计算属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">&#x27;size&#x27;</span>],</span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="attr">normalizedSize</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变变更这个对象或数组本身<strong>将会</strong>影响到父组件的状态。</p>
<h2 id="Prop-验证"><a href="#Prop-验证" class="headerlink" title="Prop 验证"></a>Prop 验证</h2><hr>
<p>我们可以为组件的 prop 指定验证要求，例如你知道的这些类型。如果有一个需求没有被满足，则 Vue 会在浏览器控制台中警告你。这在开发一个会被别人用到的组件时尤其有帮助。</p>
<p>为了定制 prop 的验证方式，你可以为 <code>props</code> 中的值提供一个带有验证需求的对象，而不是一个字符串数组。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;my-component&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="comment">// 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)</span></span><br><span class="line">    <span class="attr">propA</span>: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// 多个可能的类型</span></span><br><span class="line">    <span class="attr">propB</span>: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">    <span class="comment">// 必填的字符串</span></span><br><span class="line">    <span class="attr">propC</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="built_in">String</span>,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的数字</span></span><br><span class="line">    <span class="attr">propD</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的对象</span></span><br><span class="line">    <span class="attr">propE</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="built_in">Object</span>,</span><br><span class="line">      <span class="comment">// 对象或数组默认值必须从一个工厂函数获取</span></span><br><span class="line">      <span class="attr">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">message</span>: <span class="string">&#x27;hello&#x27;</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 自定义验证函数</span></span><br><span class="line">    <span class="attr">propF</span>: &#123;</span><br><span class="line">      <span class="attr">validator</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个值必须匹配下列字符串中的一个</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;success&#x27;</span>, <span class="string">&#x27;warning&#x27;</span>, <span class="string">&#x27;danger&#x27;</span>].indexOf(value) !== -<span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。</p>
<p>注意那些 prop 会在一个组件实例创建<strong>之前</strong>进行验证，所以实例的 property (如 <code>data</code>、<code>computed</code> 等) 在 <code>default</code> 或 <code>validator</code> 函数中是不可用的。</p>
<h3 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h3><p><code>type</code> 可以是下列原生构造函数中的一个：</p>
<ul>
<li><code>String</code></li>
<li><code>Number</code></li>
<li><code>Boolean</code></li>
<li><code>Array</code></li>
<li><code>Object</code></li>
<li><code>Date</code></li>
<li><code>Function</code></li>
<li><code>Symbol</code></li>
</ul>
<p>额外的，<code>type</code> 还可以是一个自定义的构造函数，并且通过 <code>instanceof</code> 来进行检查确认。例如，给定下列现成的构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.firstName = firstName</span><br><span class="line">  <span class="built_in">this</span>.lastName = lastName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">author</span>: Person</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>来验证 <code>author</code> prop 的值是否是通过 <code>new Person</code> 创建的。</p>
<h2 id="非-Prop-的-Attribute"><a href="#非-Prop-的-Attribute" class="headerlink" title="非 Prop 的 Attribute"></a>非 Prop 的 Attribute</h2><hr>
<p>一个非 prop 的 attribute 是指传向一个组件，但是该组件并没有相应 prop 定义的 attribute。</p>
<p>因为显式定义的 prop 适用于向一个子组件传入信息，然而组件库的作者并不总能预见组件会被用于怎样的场景。这也是为什么组件可以接受任意的 attribute，而这些 attribute 会被添加到这个组件的根元素上。</p>
<p>例如，想象一下你通过一个 Bootstrap 插件使用了一个第三方的 <code>&lt;bootstrap-date-input&gt;</code> 组件，这个插件需要在其 <code>&lt;input&gt;</code> 上用到一个 <code>data-date-picker</code> attribute。我们可以将这个 attribute 添加到你的组件实例上：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bootstrap-date-input</span> <span class="attr">data-date-picker</span>=<span class="string">&quot;activated&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bootstrap-date-input</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后这个 <code>data-date-picker=&quot;activated&quot;</code> attribute 就会自动添加到 <code>&lt;bootstrap-date-input&gt;</code> 的根元素上。</p>
<h3 id="替换-合并已有的-Attribute"><a href="#替换-合并已有的-Attribute" class="headerlink" title="替换/合并已有的 Attribute"></a>替换/合并已有的 Attribute</h3><p>想象一下 <code>&lt;bootstrap-date-input&gt;</code> 的模板是这样的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为了给我们的日期选择器插件定制一个主题，我们可能需要像这样添加一个特别的类名：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bootstrap-date-input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">data-date-picker</span>=<span class="string">&quot;activated&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;date-picker-theme-dark&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">bootstrap-date-input</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这种情况下，我们定义了两个不同的 <code>class</code> 的值：</p>
<ul>
<li><code>form-control</code>，这是在组件的模板内设置好的</li>
<li><code>date-picker-theme-dark</code>，这是从组件的父级传入的</li>
</ul>
<p>对于绝大多数 attribute 来说，从外部提供给组件的值会替换掉组件内部设置好的值。所以如果传入 <code>type=&quot;text&quot;</code> 就会替换掉 <code>type=&quot;date&quot;</code> 并把它破坏！庆幸的是，<code>class</code> 和 <code>style</code> attribute 会稍微智能一些，即两边的值会被合并起来，从而得到最终的值：<code>form-control date-picker-theme-dark</code>。</p>
<h3 id="禁用-Attribute-继承"><a href="#禁用-Attribute-继承" class="headerlink" title="禁用 Attribute 继承"></a>禁用 Attribute 继承</h3><p>如果你<strong>不</strong>希望组件的根元素继承 attribute，你可以在组件的选项中设置 <code>inheritAttrs: false</code>。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;my-component&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">inheritAttrs</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这尤其适合配合实例的 <code>$attrs</code> property 使用，该 property 包含了传递给一个组件的 attribute 名和 attribute 值，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">placeholder</span>: <span class="string">&#x27;Enter your username&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了 <code>inheritAttrs: false</code> 和 <code>$attrs</code>，你就可以手动决定这些 attribute 会被赋予哪个元素。在撰写基础组件的时候是常会用到的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;label&gt;</span><br><span class="line">	&#123;&#123; label &#125;&#125;</span><br><span class="line">	&lt;input</span><br><span class="line">		v-bind=&quot;$attrs&quot;</span><br><span class="line">		:value=&quot;value&quot;</span><br><span class="line">		@input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span><br><span class="line">	&gt;</span><br><span class="line">&lt;/label&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">	name: &quot;base-input&quot;,</span><br><span class="line">	inheritAttrs: false,</span><br><span class="line">	props: [&#x27;label&#x27;, &#x27;value&#x27;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>inheritAttrs: false</code> 选项<strong>不会</strong>影响 <code>style</code> 和 <code>class</code> 的绑定。</p>
<p>这个模式允许你在使用基础组件的时候更像是使用原始的 HTML 元素，而不会担心哪个元素是真正的根元素：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">&quot;username&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">required</span></span></span><br><span class="line"><span class="tag">  <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h1><h2 id="自定义组件的-v-model"><a href="#自定义组件的-v-model" class="headerlink" title="自定义组件的 v-model"></a>自定义组件的 <code>v-model</code></h2><hr>
<p>一个组件上的 <code>v-model</code> 默认会利用名为 <code>value</code> 的 prop 和名为 <code>input</code> 的事件，但是像单选框、复选框等类型的输入控件可能会将 <code>value</code> attribute 用于<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value">不同的目的</a>。<code>model</code> 选项可以用来避免这样的冲突：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">	type=&quot;checkbox&quot;</span><br><span class="line">	:checked=&quot;checked&quot;</span><br><span class="line">	@change=&quot;$emit(&#x27;change&#x27;, $event.target.checked)&quot;</span><br><span class="line">&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">	name: &#x27;base-checkbox&#x27;,</span><br><span class="line">	model: &#123;</span><br><span class="line">    prop: &#x27;checked&#x27;,</span><br><span class="line">    event: &#x27;change&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">	props: &#123;</span><br><span class="line">    checked: Boolean</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在在这个组件上使用 <code>v-model</code> 的时候：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-checkbox</span> <span class="attr">v-model</span>=<span class="string">&quot;lovingVue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">base-checkbox</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的 <code>lovingVue</code> 的值将会传入这个名为 <code>checked</code> 的 prop。同时当 <code>&lt;base-checkbox&gt;</code> 触发一个 <code>change</code> 事件并附带一个新的值的时候，这个 <code>lovingVue</code> 的 property 将会被更新。</p>
<p>注意你仍然需要在组件的 <code>props</code> 选项里声明 <code>checked</code> 这个 prop。</p>
<h2 id="将原生事件绑定到组件"><a href="#将原生事件绑定到组件" class="headerlink" title="将原生事件绑定到组件"></a>将原生事件绑定到组件</h2><hr>
<p>你可能有很多次想要在一个组件的根元素上直接监听一个原生事件。这时，你可以使用 <code>v-on</code> 的 <code>.native</code> 修饰符：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-input</span> @<span class="attr">focus.native</span>=<span class="string">&quot;onFocus&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在有的时候这是很有用的，不过在你尝试监听一个类似 <code>&lt;input&gt;</code> 的非常特定的元素时，这并不是个好主意。比如上述 <code>&lt;base-input&gt;</code> 组件可能做了如下重构，所以根元素实际上是一个 <code>&lt;label&gt;</code> 元素：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">  &#123;&#123; label &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:value</span>=<span class="string">&quot;value&quot;</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">input</span>=<span class="string">&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这时，父级的 <code>.native</code> 监听器将静默失败。它不会产生任何报错，但是 <code>onFocus</code> 处理函数不会如你预期地被调用。</p>
<p>为了解决这个问题，Vue 提供了一个 <code>$listeners</code> property，它是一个对象，里面包含了作用在这个组件上的所有监听器。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">focus</span>: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  <span class="attr">input</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了这个 <code>$listeners</code> property，你就可以配合 <code>v-on=&quot;$listeners&quot;</code> 将所有的事件监听器指向这个组件的某个特定的子元素。对于类似 <code>&lt;input&gt;</code> 的你希望它也可以配合 <code>v-model</code> 工作的组件来说，为这些监听器创建一个类似下述 <code>inputListeners</code> 的计算属性通常是非常有用的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;label&gt;</span><br><span class="line">	&#123;&#123; label &#125;&#125;</span><br><span class="line">	&lt;input</span><br><span class="line">		v-bind=&quot;$attrs&quot;</span><br><span class="line">		:value=&quot;value&quot;</span><br><span class="line">		v-on=&quot;inputListeners&quot;</span><br><span class="line">	&gt;</span><br><span class="line">&lt;/label&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">	name: &quot;base-input&quot;,</span><br><span class="line">	inheritAttrs: false,</span><br><span class="line">	props: [&#x27;label&#x27;, &#x27;value&#x27;],</span><br><span class="line">	computed: &#123;</span><br><span class="line">		inputListeners: function () &#123;</span><br><span class="line">			var vm = this</span><br><span class="line">      // `Object.assign` 将所有的对象合并为一个新对象</span><br><span class="line">      return Object.assign(&#123;&#125;,</span><br><span class="line">				// 我们从父级添加所有的监听器</span><br><span class="line">        this.$listeners,</span><br><span class="line">        // 然后我们添加自定义监听器，</span><br><span class="line">        // 或覆写一些监听器的行为</span><br><span class="line">        &#123;</span><br><span class="line">          // 这里确保组件配合 `v-model` 的工作</span><br><span class="line">          input: function (event) &#123;</span><br><span class="line">            vm.$emit(&#x27;input&#x27;, event.target.value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在 <code>&lt;base-input&gt;</code> 组件是一个<strong>完全透明的包裹器</strong>了，也就是说它可以完全像一个普通的 <code>&lt;input&gt;</code> 元素一样使用了：所有跟它相同的 attribute 和监听器都可以工作，不必再使用 <code>.native</code> 监听器。</p>
<h2 id="sync-修饰符"><a href="#sync-修饰符" class="headerlink" title=".sync 修饰符"></a><code>.sync</code> 修饰符</h2><hr>
<p>在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以变更父组件，且在父组件和子组件都没有明显的变更来源。</p>
<p>这也是为什么我们推荐以 <code>update:myPropName</code> 的模式触发事件取而代之。举个例子，在一个包含 <code>title</code> prop 的假设的组件中，我们可以用以下方法表达对其赋新值的意图：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&#x27;update:title&#x27;</span>, newTitle)</span><br></pre></td></tr></table></figure>

<p>然后父组件可以监听那个事件并根据需要更新一个本地的数据 property。例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:title</span>=<span class="string">&quot;doc.title&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">update:title</span>=<span class="string">&quot;doc.title = $event&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为了方便起见，我们为这种模式提供一个缩写，即 <code>.sync</code> 修饰符：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span> <span class="attr">:title.sync</span>=<span class="string">&quot;doc.title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意带有 <code>.sync</code> 修饰符的 <code>v-bind</code> <strong>不能</strong>和表达式一起使用 (例如 <code>v-bind:title.sync=”doc.title + ‘!’”</code> 是无效的)。取而代之的是，你只能提供你想要绑定的 property 名，类似 <code>v-model</code>。</p>
<p>当我们用一个对象同时设置多个 prop 的时候，也可以将这个 <code>.sync</code> 修饰符和 <code>v-bind</code> 配合使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span> <span class="attr">v-bind.sync</span>=<span class="string">&quot;doc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样会把 <code>doc</code> 对象中的每一个 property (如 <code>title</code>) 都作为一个独立的 prop 传进去，然后各自添加用于更新的 <code>v-on</code> 监听器。</p>
<p>将 <code>v-bind.sync</code> 用在一个字面量的对象上，例如 <code>v-bind.sync=”&#123; title: doc.title &#125;”</code>，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。</p>
<h1 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h1><h2 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><hr>
<p>有时让插槽内容能够访问子组件中才有的数据是很有用的。例如，设想一个带有如下模板的 <code>&lt;current-user&gt;</code> 组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span>&#123;&#123; user.lastName &#125;&#125;<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们可能想换掉备用内容，用名而非姓来显示。如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span><br><span class="line">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然而上述代码不会正常工作，因为只有 <code>&lt;current-user&gt;</code> 组件可以访问到 <code>user</code> 而我们提供的内容是在父级渲染的。</p>
<p>为了让 <code>user</code> 在父级的插槽内容中可用，我们可以将 <code>user</code> 作为 <code>&lt;slot&gt;</code> 元素的一个 attribute 绑定上去：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:user</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; user.lastName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>绑定在 <code>&lt;slot&gt;</code> 元素上的 attribute 被称为<strong>插槽 prop</strong>。现在在父级作用域中，我们可以使用带值的 <code>v-slot</code> 来定义我们提供的插槽 prop 的名字：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们选择将包含所有插槽 prop 的对象命名为 <code>slotProps</code>，但你也可以使用任意你喜欢的名字。</p>
<h3 id="独占默认插槽的缩写语法"><a href="#独占默认插槽的缩写语法" class="headerlink" title="独占默认插槽的缩写语法"></a>独占默认插槽的缩写语法</h3><p>在上述情况下，当被提供的内容<em>只有</em>默认插槽时，组件的标签才可以被当作插槽的模板来使用。这样我们就可以把 <code>v-slot</code> 直接用在组件上：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这种写法还可以更简单。就像假定未指明的内容对应默认插槽一样，不带参数的 <code>v-slot</code> 被假定对应默认插槽：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意默认插槽的缩写语法<strong>不能</strong>和具名插槽混用，因为它会导致作用域不明确：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 无效，会导致警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:other</span>=<span class="string">&quot;otherSlotProps&quot;</span>&gt;</span></span><br><span class="line">    slotProps is NOT available here</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>只要出现多个插槽，请始终为<em>所有的</em>插槽使用完整的基于 <code>&lt;template&gt;</code> 的语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:other</span>=<span class="string">&quot;otherSlotProps&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="解构插槽-Prop"><a href="#解构插槽-Prop" class="headerlink" title="解构插槽 Prop"></a>解构插槽 Prop</h3><p>作用域插槽的内部工作原理是将你的插槽内容包裹在一个拥有单个参数的函数里：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">slotProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 插槽内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这意味着 <code>v-slot</code> 的值实际上可以是任何能够作为函数定义中的参数的 JavaScript 表达式。所以在支持的环境下单文件组件或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9">现代浏览器</a>)，你也可以使用 ES2015 解构来传入具体的插槽 prop，如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; user &#125;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样可以使模板更简洁，尤其是在该插槽提供了多个 prop 的时候。它同样开启了 prop 重命名等其它可能，例如将 <code>user</code> 重命名为 <code>person</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; user: person &#125;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; person.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你甚至可以定义后备内容，用于插槽 prop 是 undefined 的情形：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; user = &#123; firstName: &#x27;Guest&#x27; &#125; &#125;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="具名插槽的缩写"><a href="#具名插槽的缩写" class="headerlink" title="具名插槽的缩写"></a>具名插槽的缩写</h2><hr>
<p>跟 <code>v-on</code> 和 <code>v-bind</code> 一样，<code>v-slot</code> 也有缩写，即把参数之前的所有内容 (<code>v-slot:</code>) 替换为字符 <code>#</code>。例如 <code>v-slot:header</code> 可以被重写为 <code>#header</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然而，和其它指令一样，该缩写只在其有参数的时候才可用。这意味着以下语法是无效的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这样会触发一个警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">current-user</span> #=<span class="string">&quot;&#123; user &#125;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你希望使用缩写的话，你必须始终以明确插槽名取而代之：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> #<span class="attr">default</span>=<span class="string">&quot;&#123; user &#125;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="其它示例"><a href="#其它示例" class="headerlink" title="其它示例"></a>其它示例</h2><hr>
<p>这只是作用域插槽用武之地的冰山一角。想了解更多现实生活中的作用域插槽的用法，我们推荐浏览诸如 <a href="https://github.com/Akryum/vue-virtual-scroller">Vue Virtual Scroller</a>、<a href="https://github.com/posva/vue-promised">Vue Promised</a> 和 <a href="https://github.com/LinusBorg/portal-vue">Portal Vue</a> 等库。</p>
<h1 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h1><hr>
<p>在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;async-example&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 向 `resolve` 回调传递组件定义</span></span><br><span class="line">    resolve(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;I am async!&lt;/div&gt;&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如你所见，这个工厂函数会收到一个 <code>resolve</code> 回调，这个回调函数会在你从服务器得到组件定义的时候被调用。你也可以调用 <code>reject(reason)</code> 来表示加载失败。这里的 <code>setTimeout</code> 是为了演示用的，如何获取组件取决于你自己。一个推荐的做法是将异步组件和 <a href="https://webpack.js.org/guides/code-splitting/">webpack 的 code-splitting 功能</a>一起配合使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;async-webpack-example&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个特殊的 `require` 语法将会告诉 webpack</span></span><br><span class="line">  <span class="comment">// 自动将你的构建代码切割成多个包，这些包</span></span><br><span class="line">  <span class="comment">// 会通过 Ajax 请求加载</span></span><br><span class="line">  <span class="built_in">require</span>([<span class="string">&#x27;./my-async-component&#x27;</span>], resolve)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>你也可以在工厂函数中返回一个 <code>Promise</code>，所以把 webpack 2 和 ES2015 语法加在一起，我们可以这样使用动态导入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(</span><br><span class="line">  <span class="string">&#x27;async-webpack-example&#x27;</span>,</span><br><span class="line">  <span class="comment">// 这个动态导入会返回一个 `Promise` 对象。</span></span><br><span class="line">  <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./my-async-component&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>当使用局部注册的时候，你也可以直接提供一个返回 <code>Promise</code> 的函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;my-component&#x27;</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./my-async-component&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="处理加载状态"><a href="#处理加载状态" class="headerlink" title="处理加载状态"></a>处理加载状态</h2><p>这里的异步组件工厂函数也可以返回一个如下格式的对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> AsyncComponent = <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">// 需要加载的组件 (应该是一个 `Promise` 对象)</span></span><br><span class="line">  <span class="attr">component</span>: <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;MyComponent&quot; */</span>， <span class="string">&#x27;./MyComponent.vue&#x27;</span>),</span><br><span class="line">  <span class="comment">// 异步组件加载时使用的组件</span></span><br><span class="line">  <span class="attr">loading</span>: LoadingComponent,</span><br><span class="line">  <span class="comment">// 加载失败时使用的组件</span></span><br><span class="line">  <span class="attr">error</span>: ErrorComponent,</span><br><span class="line">  <span class="comment">// 展示加载时组件的延时时间。默认值是 200 (毫秒)</span></span><br><span class="line">  <span class="attr">delay</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="comment">// 如果提供了超时时间且组件加载也超时了，</span></span><br><span class="line">  <span class="comment">// 则使用加载失败时使用的组件。默认值是：`Infinity`</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">3000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="处理边界情况"><a href="#处理边界情况" class="headerlink" title="处理边界情况"></a>处理边界情况</h1><h2 id="访问元素-amp-组件"><a href="#访问元素-amp-组件" class="headerlink" title="访问元素 &amp; 组件"></a>访问元素 &amp; 组件</h2><hr>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>在此之前，在我们描述访问父级组件实例的时候，展示过一个类似这样的例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">google-map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">google-map-region</span> <span class="attr">v-bind:shape</span>=<span class="string">&quot;cityBoundaries&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">google-map-markers</span> <span class="attr">v-bind:places</span>=<span class="string">&quot;iceCreamShops&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">google-map-markers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">google-map-region</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">google-map</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这个组件里，所有 <code>&lt;google-map&gt;</code> 的后代都需要访问一个 <code>getMap</code> 方法，以便知道要跟哪个地图进行交互。不幸的是，使用 <code>$parent</code> property 无法很好的扩展到更深层级的嵌套组件上。这也是依赖注入的用武之地，它用到了两个新的实例选项：<code>provide</code> 和 <code>inject</code>。</p>
<p><code>provide</code> 选项允许我们指定我们想要<strong>提供</strong>给后代组件的数据/方法。在这个例子中，就是 <code>&lt;google-map&gt;</code> 内部的 <code>getMap</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">provide () &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">getMap</span>: <span class="built_in">this</span>.getMap</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在任何后代组件里，我们都可以使用 <code>inject</code> 选项来接收指定的我们想要添加在这个实例上的 property：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">inject: [<span class="string">&#x27;getMap&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>相比 <code>$parent</code> 来说，这个用法可以让我们在<em>任意</em>后代组件中访问 <code>getMap</code>，而不需要暴露整个 <code>&lt;google-map&gt;</code> 实例。这允许我们更好的持续研发该组件，而不需要担心我们可能会改变/移除一些子组件依赖的东西。同时这些组件之间的接口是始终明确定义的，就和 <code>props</code> 一样。</p>
<p>实际上，你可以把依赖注入看作一部分“大范围有效的 prop”，除了：</p>
<ul>
<li>祖先组件不需要知道哪些后代组件使用它提供的 property</li>
<li>后代组件不需要知道被注入的 property 来自哪里</li>
</ul>
<p>然而，依赖注入还是有负面影响的。它将你应用程序中的组件与它们当前的组织方式耦合起来，使重构变得更加困难。同时所提供的 property 是非响应式的。这是出于设计的考虑，因为使用它们来创建一个中心化规模化的数据跟使用 <code>$root</code>做这件事都是不够好的。如果你想要共享的这个 property 是你的应用特有的，而不是通用化的，或者如果你想在祖先组件中更新所提供的数据，那么这意味着你可能需要换用一个像 Vuex 这样真正的状态管理方案了。</p>
<h2 id="程序化的事件侦听器"><a href="#程序化的事件侦听器" class="headerlink" title="程序化的事件侦听器"></a>程序化的事件侦听器</h2><hr>
<p>现在，你已经知道了 <code>$emit</code> 的用法，它可以被 <code>v-on</code> 侦听，但是 Vue 实例同时在其事件接口中提供了其它的方法。我们可以：</p>
<ul>
<li>通过 <code>$on(eventName, eventHandler)</code> 侦听一个事件</li>
<li>通过 <code>$once(eventName, eventHandler)</code> 一次性侦听一个事件</li>
<li>通过 <code>$off(eventName, eventHandler)</code> 停止侦听一个事件</li>
</ul>
<p>你通常不会用到这些，但是当你需要在一个组件实例上手动侦听事件时，它们是派得上用场的。它们也可以用于代码组织工具。例如，你可能经常看到这种集成一个第三方库的模式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一次性将这个日期选择器附加到一个输入框上</span></span><br><span class="line"><span class="comment">// 它会被挂载到 DOM 上。</span></span><br><span class="line"><span class="attr">mounted</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Pikaday 是一个第三方日期选择器的库</span></span><br><span class="line">  <span class="built_in">this</span>.picker = <span class="keyword">new</span> Pikaday(&#123;</span><br><span class="line">    <span class="attr">field</span>: <span class="built_in">this</span>.$refs.input,</span><br><span class="line">    <span class="attr">format</span>: <span class="string">&#x27;YYYY-MM-DD&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 在组件被销毁之前，</span></span><br><span class="line"><span class="comment">// 也销毁这个日期选择器。</span></span><br><span class="line"><span class="attr">beforeDestroy</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.picker.destroy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两个潜在的问题：</p>
<ul>
<li>它需要在这个组件实例中保存这个 <code>picker</code>，如果可以的话最好只有生命周期钩子可以访问到它。这并不算严重的问题，但是它可以被视为杂物。</li>
<li>我们的建立代码独立于我们的清理代码，这使得我们比较难于程序化地清理我们建立的所有东西。</li>
</ul>
<p>你应该通过一个程序化的侦听器解决这两个问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> picker = <span class="keyword">new</span> Pikaday(&#123;</span><br><span class="line">    <span class="attr">field</span>: <span class="built_in">this</span>.$refs.input,</span><br><span class="line">    <span class="attr">format</span>: <span class="string">&#x27;YYYY-MM-DD&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.$once(<span class="string">&#x27;hook:beforeDestroy&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    picker.destroy()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用了这个策略，我甚至可以让多个输入框元素同时使用不同的 Pikaday，每个新的实例都程序化地在后期清理它自己：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mounted: function () &#123;</span><br><span class="line">  <span class="keyword">this</span>.attachDatepicker(<span class="string">&#x27;startDateInput&#x27;</span>)</span><br><span class="line">  <span class="keyword">this</span>.attachDatepicker(<span class="string">&#x27;endDateInput&#x27;</span>)</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  attachDatepicker: function (refName) &#123;</span><br><span class="line">    <span class="keyword">var</span> picker = <span class="keyword">new</span> Pikaday(&#123;</span><br><span class="line">      field: <span class="keyword">this</span>.$refs[refName],</span><br><span class="line">      format: <span class="string">&#x27;YYYY-MM-DD&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.$once(<span class="string">&#x27;hook:beforeDestroy&#x27;</span>, function () &#123;</span><br><span class="line">      picker.destroy()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查阅<a href="https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-programmatic-event-listeners">这个示例</a>可以了解到完整的代码。注意，即便如此，如果你发现自己不得不在单个组件里做很多建立和清理的工作，最好的方式通常还是创建更多的模块化组件。在这个例子中，我们推荐创建一个可复用的 <code>&lt;input-datepicker&gt;</code> 组件。</p>
<p>注意 Vue 的事件系统不同于浏览器的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget">EventTarget API</a>。尽管它们工作起来是相似的，但是 <code>$emit</code>、<code>$on</code>, 和 <code>$off</code> 并不是 <code>dispatchEvent</code>、<code>addEventListener</code> 和 <code>removeEventListener</code> 的别名。</p>
<h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><hr>
<h3 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h3><p>组件是可以在它们自己的模板中调用自身的。不过它们只能通过 <code>name</code> 选项来做这件事：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">name: <span class="string">&#x27;unique-name-of-my-component&#x27;</span></span><br></pre></td></tr></table></figure>

<p>当你使用 <code>Vue.component</code> 全局注册一个组件时，这个全局的 ID 会自动设置为该组件的 <code>name</code> 选项。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;unique-name-of-my-component&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>稍有不慎，递归组件就可能导致无限循环：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">name: <span class="string">&#x27;stack-overflow&#x27;</span>,</span><br><span class="line"><span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>类似上述的组件将会导致“max stack size exceeded”错误，所以请确保递归调用是条件性的 (例如使用一个最终会得到 <code>false</code> 的 <code>v-if</code>)。</p>
<h3 id="组件之间的循环引用"><a href="#组件之间的循环引用" class="headerlink" title="组件之间的循环引用"></a>组件之间的循环引用</h3><p>假设你需要构建一个文件目录树，像访达或资源管理器那样的。你可能有一个 <code>&lt;tree-folder&gt;</code> 组件，模板是这样的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; folder.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tree-folder-contents</span> <span class="attr">:children</span>=<span class="string">&quot;folder.children&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>还有一个 <code>&lt;tree-folder-contents&gt;</code> 组件，模板是这样的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;child in children&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tree-folder</span> <span class="attr">v-if</span>=<span class="string">&quot;child.children&quot;</span> <span class="attr">:folder</span>=<span class="string">&quot;child&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span>&#123;&#123; child.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当你仔细观察的时候，你会发现这些组件在渲染树中互为对方的后代<em>和</em>祖先——一个悖论！当通过 <code>Vue.component</code> 全局注册组件的时候，这个悖论会被自动解开。如果你是这样做的，那么你可以跳过这里。</p>
<p>然而，如果你使用一个<em>模块系统</em>依赖/导入组件，例如通过 webpack 或 Browserify，你会遇到一个错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Failed to mount component: template or render function not defined.</span><br></pre></td></tr></table></figure>

<p>为了解释这里发生了什么，我们先把两个组件称为 A 和 B。模块系统发现它需要 A，但是首先 A 依赖 B，但是 B 又依赖 A，但是 A 又依赖 B，如此往复。这变成了一个循环，不知道如何不经过其中一个组件而完全解析出另一个组件。为了解决这个问题，我们需要给模块系统一个点，在那里“A <em>反正</em>是需要 B 的，但是我们不需要先解析 B。”</p>
<p>在我们的例子中，把 <code>&lt;tree-folder&gt;</code> 组件设为了那个点。我们知道那个产生悖论的子组件是 <code>&lt;tree-folder-contents&gt;</code> 组件，所以我们会等到生命周期钩子 <code>beforeCreate</code> 时去注册它：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">beforeCreate: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.$options.components.TreeFolderContents = <span class="built_in">require</span>(<span class="string">&#x27;./tree-folder-contents.vue&#x27;</span>).default</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，在本地注册组件的时候，你可以使用 webpack 的异步 <code>import</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">components: &#123;</span><br><span class="line">  <span class="attr">TreeFolderContents</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./tree-folder-contents.vue&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样问题就解决了！</p>
<h2 id="模板定义的替代品"><a href="#模板定义的替代品" class="headerlink" title="模板定义的替代品"></a>模板定义的替代品</h2><hr>
<h3 id="内联模板"><a href="#内联模板" class="headerlink" title="内联模板"></a>内联模板</h3><p>当 <code>inline-template</code> 这个特殊的 attribute 出现在一个子组件上时，这个组件将会使用其里面的内容作为模板，而不是将其作为被分发的内容。这使得模板的撰写工作更加灵活。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">inline-template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>These are compiled as the component&#x27;s own template.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Not parent&#x27;s transclusion content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>内联模板需要定义在 Vue 所属的 DOM 元素内。</p>
<p>不过，<code>inline-template</code> 会让模板的作用域变得更加难以理解。所以作为最佳实践，请在组件内优先选择 <code>template</code> 选项或 <code>.vue</code> 文件里的一个 <code>&lt;template&gt;</code> 元素来定义模板。</p>
<h3 id="X-Template"><a href="#X-Template" class="headerlink" title="X-Template"></a>X-Template</h3><p>另一个定义模板的方式是在一个 <code>&lt;script&gt;</code> 元素中，并为其带上 <code>text/x-template</code> 的类型，然后通过一个 id 将模板引用过去。例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/x-template&quot;</span> <span class="attr">id</span>=<span class="string">&quot;hello-world-template&quot;</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello hello hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">Vue.component(&#x27;hello-world&#x27;, &#123;</span><br><span class="line">  template: &#x27;#hello-world-template&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>x-template 需要定义在 Vue 所属的 DOM 元素外。</p>
<p>这些可以用于模板特别大的 demo 或极小型的应用，但是其它情况下请避免使用，因为这会将模板和该组件的其它定义分离开。</p>
<h2 id="控制更新"><a href="#控制更新" class="headerlink" title="控制更新"></a>控制更新</h2><p>感谢 Vue 的响应式系统，它始终知道何时进行更新 (如果你用对了的话)。不过还是有一些边界情况，你想要强制更新，尽管表面上看响应式的数据没有发生改变。也有一些情况是你想阻止不必要的更新。</p>
<h3 id="强制更新"><a href="#强制更新" class="headerlink" title="强制更新"></a>强制更新</h3><p>如果你发现你自己需要在 Vue 中做一次强制更新，99.9% 的情况，是你在某个地方做错了事。</p>
<p>你可能还没有留意到<a href="https://cn.vuejs.org/v2/guide/list.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">数组</a>或<a href="https://cn.vuejs.org/v2/guide/list.html#%E5%AF%B9%E8%B1%A1%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">对象</a>的变更检测注意事项，或者你可能依赖了一个未被 Vue 的响应式系统追踪的状态。</p>
<p>然而，如果你已经做到了上述的事项仍然发现在极少数的情况下需要手动强制更新，那么你可以通过 <a href="https://cn.vuejs.org/v2/api/#vm-forceUpdate"><code>$forceUpdate</code></a> 来做这件事。</p>
<h3 id="通过-v-once-创建低开销的静态组件"><a href="#通过-v-once-创建低开销的静态组件" class="headerlink" title="通过 v-once 创建低开销的静态组件"></a>通过 <code>v-once</code> 创建低开销的静态组件</h3><p>渲染普通的 HTML 元素在 Vue 中是非常快速的，但有的时候你可能有一个组件，这个组件包含了<strong>大量</strong>静态内容。在这种情况下，你可以在根元素上添加 <code>v-once</code> attribute 以确保这些内容只计算一次然后缓存起来，就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;terms-of-service&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div v-once&gt;</span></span><br><span class="line"><span class="string">      &lt;h1&gt;Terms of Service&lt;/h1&gt;</span></span><br><span class="line"><span class="string">      ... a lot of static content ...</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>再说一次，试着不要过度使用这个模式。当你需要渲染大量静态内容时，极少数的情况下它会给你带来便利，除非你非常留意渲染变慢了，不然它完全是没有必要的——再加上它在后期会带来很多困惑。例如，设想另一个开发者并不熟悉 <code>v-once</code> 或漏看了它在模板中，他们可能会花很多个小时去找出模板为什么无法正确更新。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
</search>
